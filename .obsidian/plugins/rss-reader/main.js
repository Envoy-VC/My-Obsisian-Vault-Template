/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
https://github.com/joethei/obisidian-rss
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/ts-md5/dist/md5.js
var require_md5 = __commonJS({
  "node_modules/ts-md5/dist/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Md54 = function() {
      function Md55() {
        this._dataLength = 0;
        this._bufferLength = 0;
        this._state = new Int32Array(4);
        this._buffer = new ArrayBuffer(68);
        this._buffer8 = new Uint8Array(this._buffer, 0, 68);
        this._buffer32 = new Uint32Array(this._buffer, 0, 17);
        this.start();
      }
      Md55.hashStr = function(str, raw) {
        if (raw === void 0) {
          raw = false;
        }
        return this.onePassHasher.start().appendStr(str).end(raw);
      };
      Md55.hashAsciiStr = function(str, raw) {
        if (raw === void 0) {
          raw = false;
        }
        return this.onePassHasher.start().appendAsciiStr(str).end(raw);
      };
      Md55._hex = function(x) {
        var hc = Md55.hexChars;
        var ho = Md55.hexOut;
        var n;
        var offset2;
        var j;
        var i;
        for (i = 0; i < 4; i += 1) {
          offset2 = i * 8;
          n = x[i];
          for (j = 0; j < 8; j += 2) {
            ho[offset2 + 1 + j] = hc.charAt(n & 15);
            n >>>= 4;
            ho[offset2 + 0 + j] = hc.charAt(n & 15);
            n >>>= 4;
          }
        }
        return ho.join("");
      };
      Md55._md5cycle = function(x, k) {
        var a = x[0];
        var b = x[1];
        var c = x[2];
        var d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      };
      Md55.prototype.start = function() {
        this._dataLength = 0;
        this._bufferLength = 0;
        this._state.set(Md55.stateIdentity);
        return this;
      };
      Md55.prototype.appendStr = function(str) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var code;
        var i;
        for (i = 0; i < str.length; i += 1) {
          code = str.charCodeAt(i);
          if (code < 128) {
            buf8[bufLen++] = code;
          } else if (code < 2048) {
            buf8[bufLen++] = (code >>> 6) + 192;
            buf8[bufLen++] = code & 63 | 128;
          } else if (code < 55296 || code > 56319) {
            buf8[bufLen++] = (code >>> 12) + 224;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          } else {
            code = (code - 55296) * 1024 + (str.charCodeAt(++i) - 56320) + 65536;
            if (code > 1114111) {
              throw new Error("Unicode standard supports code points up to U+10FFFF");
            }
            buf8[bufLen++] = (code >>> 18) + 240;
            buf8[bufLen++] = code >>> 12 & 63 | 128;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          }
          if (bufLen >= 64) {
            this._dataLength += 64;
            Md55._md5cycle(this._state, buf32);
            bufLen -= 64;
            buf32[0] = buf32[16];
          }
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.appendAsciiStr = function(str) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var i;
        var j = 0;
        for (; ; ) {
          i = Math.min(str.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = str.charCodeAt(j++);
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          Md55._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.appendByteArray = function(input) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var i;
        var j = 0;
        for (; ; ) {
          i = Math.min(input.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = input[j++];
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          Md55._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.getState = function() {
        var s = this._state;
        return {
          buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
          buflen: this._bufferLength,
          length: this._dataLength,
          state: [s[0], s[1], s[2], s[3]]
        };
      };
      Md55.prototype.setState = function(state) {
        var buf = state.buffer;
        var x = state.state;
        var s = this._state;
        var i;
        this._dataLength = state.length;
        this._bufferLength = state.buflen;
        s[0] = x[0];
        s[1] = x[1];
        s[2] = x[2];
        s[3] = x[3];
        for (i = 0; i < buf.length; i += 1) {
          this._buffer8[i] = buf.charCodeAt(i);
        }
      };
      Md55.prototype.end = function(raw) {
        if (raw === void 0) {
          raw = false;
        }
        var bufLen = this._bufferLength;
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var i = (bufLen >> 2) + 1;
        this._dataLength += bufLen;
        var dataBitsLen = this._dataLength * 8;
        buf8[bufLen] = 128;
        buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
        buf32.set(Md55.buffer32Identity.subarray(i), i);
        if (bufLen > 55) {
          Md55._md5cycle(this._state, buf32);
          buf32.set(Md55.buffer32Identity);
        }
        if (dataBitsLen <= 4294967295) {
          buf32[14] = dataBitsLen;
        } else {
          var matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
          if (matches === null) {
            return;
          }
          var lo = parseInt(matches[2], 16);
          var hi = parseInt(matches[1], 16) || 0;
          buf32[14] = lo;
          buf32[15] = hi;
        }
        Md55._md5cycle(this._state, buf32);
        return raw ? this._state : Md55._hex(this._state);
      };
      Md55.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
      Md55.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Md55.hexChars = "0123456789abcdef";
      Md55.hexOut = [];
      Md55.onePassHasher = new Md55();
      return Md55;
    }();
    exports.Md5 = Md54;
    if (Md54.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
      throw new Error("Md5 self test failed.");
    }
  }
});

// node_modules/feather-icons/dist/feather.js
var require_feather = __commonJS({
  "node_modules/feather-icons/dist/feather.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["feather"] = factory();
      else
        root["feather"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, {
              configurable: false,
              enumerable: true,
              get: getter
            });
          }
        };
        __webpack_require__.r = function(exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? function getDefault() {
            return module3["default"];
          } : function getModuleExports() {
            return module3;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 0);
      }({
        "./dist/icons.json": function(module3) {
          module3.exports = { "activity": '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>', "airplay": '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>', "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>', "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>', "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>', "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>', "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>', "anchor": '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>', "aperture": '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>', "archive": '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>', "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>', "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>', "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>', "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>', "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>', "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>', "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>', "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>', "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>', "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>', "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>', "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>', "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>', "award": '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>', "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>', "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>', "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>', "battery": '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>', "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "bell": '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>', "bluetooth": '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>', "bold": '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>', "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>', "book": '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>', "bookmark": '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>', "box": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "briefcase": '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>', "calendar": '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>', "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>', "camera": '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>', "cast": '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>', "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>', "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>', "check": '<polyline points="20 6 9 17 4 12"></polyline>', "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>', "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>', "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>', "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>', "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>', "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>', "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>', "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>', "chrome": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>', "circle": '<circle cx="12" cy="12" r="10"></circle>', "clipboard": '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>', "clock": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>', "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>', "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>', "cloud": '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>', "code": '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>', "codepen": '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>', "codesandbox": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "coffee": '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>', "columns": '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>', "command": '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>', "compass": '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>', "copy": '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>', "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>', "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>', "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>', "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>', "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>', "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>', "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>', "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>', "cpu": '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>', "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>', "crop": '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>', "crosshair": '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>', "database": '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>', "delete": '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>', "disc": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>', "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>', "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>', "divide": '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>', "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>', "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>', "download": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>', "dribbble": '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>', "droplet": '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>', "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>', "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>', "edit": '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>', "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>', "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "eye": '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>', "facebook": '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>', "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>', "feather": '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>', "figma": '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>', "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>', "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>', "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>', "file": '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>', "film": '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>', "filter": '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>', "flag": '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>', "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>', "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>', "folder": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>', "framer": '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>', "frown": '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "gift": '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>', "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>', "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>', "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>', "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>', "github": '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>', "gitlab": '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>', "globe": '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>', "grid": '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>', "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>', "hash": '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>', "headphones": '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>', "heart": '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>', "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>', "hexagon": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>', "home": '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', "image": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>', "inbox": '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>', "info": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>', "instagram": '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>', "italic": '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>', "key": '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>', "layers": '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>', "layout": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>', "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>', "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>', "link": '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>', "linkedin": '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>', "list": '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>', "loader": '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>', "lock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>', "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>', "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>', "mail": '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>', "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>', "map": '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>', "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "maximize": '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>', "meh": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "menu": '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>', "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>', "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>', "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "mic": '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "minimize": '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>', "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>', "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>', "minus": '<line x1="5" y1="12" x2="19" y2="12"></line>', "monitor": '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>', "moon": '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>', "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>', "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>', "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>', "move": '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>', "music": '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>', "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>', "navigation": '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>', "octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>', "package": '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "paperclip": '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>', "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>', "pause": '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>', "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>', "percent": '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>', "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>', "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone": '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>', "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>', "play": '<polygon points="5 3 19 12 5 21 5 3"></polygon>', "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus": '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>', "pocket": '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>', "power": '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>', "printer": '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>', "radio": '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>', "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>', "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>', "repeat": '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>', "rewind": '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>', "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>', "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>', "rss": '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>', "save": '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>', "scissors": '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>', "search": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>', "send": '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>', "server": '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>', "settings": '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>', "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>', "share": '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>', "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "shield": '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>', "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>', "shuffle": '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>', "sidebar": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>', "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>', "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>', "slack": '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>', "slash": '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>', "sliders": '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>', "smartphone": '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "smile": '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "speaker": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>', "square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>', "star": '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>', "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>', "sun": '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>', "sunrise": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>', "sunset": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>', "table": '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path>', "tablet": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "tag": '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>', "target": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>', "terminal": '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>', "thermometer": '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>', "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>', "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>', "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>', "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>', "tool": '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>', "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>', "trash": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>', "trello": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>', "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>', "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>', "triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>', "truck": '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>', "tv": '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>', "twitch": '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path>', "twitter": '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>', "type": '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>', "umbrella": '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>', "underline": '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>', "unlock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>', "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>', "upload": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>', "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>', "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>', "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>', "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>', "user": '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>', "users": '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>', "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "video": '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>', "voicemail": '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>', "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>', "volume": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>', "watch": '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>', "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wifi": '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wind": '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>', "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>', "x": '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>', "youtube": '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>', "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>', "zap": '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>', "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>', "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>' };
        },
        "./node_modules/classnames/dedupe.js": function(module3, exports2, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function() {
            "use strict";
            var classNames = function() {
              function StorageObject() {
              }
              StorageObject.prototype = Object.create(null);
              function _parseArray(resultSet, array) {
                var length = array.length;
                for (var i = 0; i < length; ++i) {
                  _parse(resultSet, array[i]);
                }
              }
              var hasOwn = {}.hasOwnProperty;
              function _parseNumber(resultSet, num) {
                resultSet[num] = true;
              }
              function _parseObject(resultSet, object) {
                for (var k in object) {
                  if (hasOwn.call(object, k)) {
                    resultSet[k] = !!object[k];
                  }
                }
              }
              var SPACE = /\s+/;
              function _parseString(resultSet, str) {
                var array = str.split(SPACE);
                var length = array.length;
                for (var i = 0; i < length; ++i) {
                  resultSet[array[i]] = true;
                }
              }
              function _parse(resultSet, arg) {
                if (!arg)
                  return;
                var argType = typeof arg;
                if (argType === "string") {
                  _parseString(resultSet, arg);
                } else if (Array.isArray(arg)) {
                  _parseArray(resultSet, arg);
                } else if (argType === "object") {
                  _parseObject(resultSet, arg);
                } else if (argType === "number") {
                  _parseNumber(resultSet, arg);
                }
              }
              function _classNames() {
                var len = arguments.length;
                var args = Array(len);
                for (var i = 0; i < len; i++) {
                  args[i] = arguments[i];
                }
                var classSet = new StorageObject();
                _parseArray(classSet, args);
                var list = [];
                for (var k in classSet) {
                  if (classSet[k]) {
                    list.push(k);
                  }
                }
                return list.join(" ");
              }
              return _classNames;
            }();
            if (typeof module3 !== "undefined" && module3.exports) {
              module3.exports = classNames;
            } else if (true) {
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return classNames;
              }.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
            }
          })();
        },
        "./node_modules/core-js/es/array/from.js": function(module3, exports2, __webpack_require__) {
          __webpack_require__("./node_modules/core-js/modules/es.string.iterator.js");
          __webpack_require__("./node_modules/core-js/modules/es.array.from.js");
          var path = __webpack_require__("./node_modules/core-js/internals/path.js");
          module3.exports = path.Array.from;
        },
        "./node_modules/core-js/internals/a-function.js": function(module3, exports2) {
          module3.exports = function(it) {
            if (typeof it != "function") {
              throw TypeError(String(it) + " is not a function");
            }
            return it;
          };
        },
        "./node_modules/core-js/internals/an-object.js": function(module3, exports2, __webpack_require__) {
          var isObject = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          module3.exports = function(it) {
            if (!isObject(it)) {
              throw TypeError(String(it) + " is not an object");
            }
            return it;
          };
        },
        "./node_modules/core-js/internals/array-from.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var bind = __webpack_require__("./node_modules/core-js/internals/bind-context.js");
          var toObject = __webpack_require__("./node_modules/core-js/internals/to-object.js");
          var callWithSafeIterationClosing = __webpack_require__("./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
          var isArrayIteratorMethod = __webpack_require__("./node_modules/core-js/internals/is-array-iterator-method.js");
          var toLength = __webpack_require__("./node_modules/core-js/internals/to-length.js");
          var createProperty = __webpack_require__("./node_modules/core-js/internals/create-property.js");
          var getIteratorMethod = __webpack_require__("./node_modules/core-js/internals/get-iterator-method.js");
          module3.exports = function from(arrayLike) {
            var O = toObject(arrayLike);
            var C = typeof this == "function" ? this : Array;
            var argumentsLength = arguments.length;
            var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
            var mapping = mapfn !== void 0;
            var index = 0;
            var iteratorMethod = getIteratorMethod(O);
            var length, result, step, iterator;
            if (mapping)
              mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
            if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
              iterator = iteratorMethod.call(O);
              result = new C();
              for (; !(step = iterator.next()).done; index++) {
                createProperty(result, index, mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value);
              }
            } else {
              length = toLength(O.length);
              result = new C(length);
              for (; length > index; index++) {
                createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
              }
            }
            result.length = index;
            return result;
          };
        },
        "./node_modules/core-js/internals/array-includes.js": function(module3, exports2, __webpack_require__) {
          var toIndexedObject = __webpack_require__("./node_modules/core-js/internals/to-indexed-object.js");
          var toLength = __webpack_require__("./node_modules/core-js/internals/to-length.js");
          var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/internals/to-absolute-index.js");
          module3.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIndexedObject($this);
              var length = toLength(O.length);
              var index = toAbsoluteIndex(fromIndex, length);
              var value;
              if (IS_INCLUDES && el != el)
                while (length > index) {
                  value = O[index++];
                  if (value != value)
                    return true;
                }
              else
                for (; length > index; index++)
                  if (IS_INCLUDES || index in O) {
                    if (O[index] === el)
                      return IS_INCLUDES || index || 0;
                  }
              return !IS_INCLUDES && -1;
            };
          };
        },
        "./node_modules/core-js/internals/bind-context.js": function(module3, exports2, __webpack_require__) {
          var aFunction = __webpack_require__("./node_modules/core-js/internals/a-function.js");
          module3.exports = function(fn2, that, length) {
            aFunction(fn2);
            if (that === void 0)
              return fn2;
            switch (length) {
              case 0:
                return function() {
                  return fn2.call(that);
                };
              case 1:
                return function(a) {
                  return fn2.call(that, a);
                };
              case 2:
                return function(a, b) {
                  return fn2.call(that, a, b);
                };
              case 3:
                return function(a, b, c) {
                  return fn2.call(that, a, b, c);
                };
            }
            return function() {
              return fn2.apply(that, arguments);
            };
          };
        },
        "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          module3.exports = function(iterator, fn2, value, ENTRIES) {
            try {
              return ENTRIES ? fn2(anObject(value)[0], value[1]) : fn2(value);
            } catch (error) {
              var returnMethod = iterator["return"];
              if (returnMethod !== void 0)
                anObject(returnMethod.call(iterator));
              throw error;
            }
          };
        },
        "./node_modules/core-js/internals/check-correctness-of-iteration.js": function(module3, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var SAFE_CLOSING = false;
          try {
            var called = 0;
            var iteratorWithReturn = {
              next: function() {
                return { done: !!called++ };
              },
              "return": function() {
                SAFE_CLOSING = true;
              }
            };
            iteratorWithReturn[ITERATOR] = function() {
              return this;
            };
            Array.from(iteratorWithReturn, function() {
              throw 2;
            });
          } catch (error) {
          }
          module3.exports = function(exec, SKIP_CLOSING) {
            if (!SKIP_CLOSING && !SAFE_CLOSING)
              return false;
            var ITERATION_SUPPORT = false;
            try {
              var object = {};
              object[ITERATOR] = function() {
                return {
                  next: function() {
                    return { done: ITERATION_SUPPORT = true };
                  }
                };
              };
              exec(object);
            } catch (error) {
            }
            return ITERATION_SUPPORT;
          };
        },
        "./node_modules/core-js/internals/classof-raw.js": function(module3, exports2) {
          var toString = {}.toString;
          module3.exports = function(it) {
            return toString.call(it).slice(8, -1);
          };
        },
        "./node_modules/core-js/internals/classof.js": function(module3, exports2, __webpack_require__) {
          var classofRaw = __webpack_require__("./node_modules/core-js/internals/classof-raw.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var CORRECT_ARGUMENTS = classofRaw(function() {
            return arguments;
          }()) == "Arguments";
          var tryGet = function(it, key) {
            try {
              return it[key];
            } catch (error) {
            }
          };
          module3.exports = function(it) {
            var O, tag, result;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
          };
        },
        "./node_modules/core-js/internals/copy-constructor-properties.js": function(module3, exports2, __webpack_require__) {
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var ownKeys = __webpack_require__("./node_modules/core-js/internals/own-keys.js");
          var getOwnPropertyDescriptorModule = __webpack_require__("./node_modules/core-js/internals/object-get-own-property-descriptor.js");
          var definePropertyModule = __webpack_require__("./node_modules/core-js/internals/object-define-property.js");
          module3.exports = function(target, source) {
            var keys = ownKeys(source);
            var defineProperty = definePropertyModule.f;
            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (!has(target, key))
                defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          };
        },
        "./node_modules/core-js/internals/correct-prototype-getter.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          module3.exports = !fails(function() {
            function F() {
            }
            F.prototype.constructor = null;
            return Object.getPrototypeOf(new F()) !== F.prototype;
          });
        },
        "./node_modules/core-js/internals/create-iterator-constructor.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var IteratorPrototype = __webpack_require__("./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
          var create = __webpack_require__("./node_modules/core-js/internals/object-create.js");
          var createPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/create-property-descriptor.js");
          var setToStringTag = __webpack_require__("./node_modules/core-js/internals/set-to-string-tag.js");
          var Iterators = __webpack_require__("./node_modules/core-js/internals/iterators.js");
          var returnThis = function() {
            return this;
          };
          module3.exports = function(IteratorConstructor, NAME, next) {
            var TO_STRING_TAG = NAME + " Iterator";
            IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
            setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
            Iterators[TO_STRING_TAG] = returnThis;
            return IteratorConstructor;
          };
        },
        "./node_modules/core-js/internals/create-property-descriptor.js": function(module3, exports2) {
          module3.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value
            };
          };
        },
        "./node_modules/core-js/internals/create-property.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var toPrimitive = __webpack_require__("./node_modules/core-js/internals/to-primitive.js");
          var definePropertyModule = __webpack_require__("./node_modules/core-js/internals/object-define-property.js");
          var createPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/create-property-descriptor.js");
          module3.exports = function(object, key, value) {
            var propertyKey = toPrimitive(key);
            if (propertyKey in object)
              definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
            else
              object[propertyKey] = value;
          };
        },
        "./node_modules/core-js/internals/define-iterator.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("./node_modules/core-js/internals/export.js");
          var createIteratorConstructor = __webpack_require__("./node_modules/core-js/internals/create-iterator-constructor.js");
          var getPrototypeOf = __webpack_require__("./node_modules/core-js/internals/object-get-prototype-of.js");
          var setPrototypeOf = __webpack_require__("./node_modules/core-js/internals/object-set-prototype-of.js");
          var setToStringTag = __webpack_require__("./node_modules/core-js/internals/set-to-string-tag.js");
          var hide2 = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var redefine = __webpack_require__("./node_modules/core-js/internals/redefine.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var IS_PURE = __webpack_require__("./node_modules/core-js/internals/is-pure.js");
          var Iterators = __webpack_require__("./node_modules/core-js/internals/iterators.js");
          var IteratorsCore = __webpack_require__("./node_modules/core-js/internals/iterators-core.js");
          var IteratorPrototype = IteratorsCore.IteratorPrototype;
          var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
          var ITERATOR = wellKnownSymbol("iterator");
          var KEYS = "keys";
          var VALUES = "values";
          var ENTRIES = "entries";
          var returnThis = function() {
            return this;
          };
          module3.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
            createIteratorConstructor(IteratorConstructor, NAME, next);
            var getIterationMethod = function(KIND) {
              if (KIND === DEFAULT && defaultIterator)
                return defaultIterator;
              if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                return IterablePrototype[KIND];
              switch (KIND) {
                case KEYS:
                  return function keys() {
                    return new IteratorConstructor(this, KIND);
                  };
                case VALUES:
                  return function values2() {
                    return new IteratorConstructor(this, KIND);
                  };
                case ENTRIES:
                  return function entries() {
                    return new IteratorConstructor(this, KIND);
                  };
              }
              return function() {
                return new IteratorConstructor(this);
              };
            };
            var TO_STRING_TAG = NAME + " Iterator";
            var INCORRECT_VALUES_NAME = false;
            var IterablePrototype = Iterable.prototype;
            var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
            var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
            var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
            var CurrentIteratorPrototype, methods, KEY;
            if (anyNativeIterator) {
              CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
              if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                  if (setPrototypeOf) {
                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                  } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                    hide2(CurrentIteratorPrototype, ITERATOR, returnThis);
                  }
                }
                setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                if (IS_PURE)
                  Iterators[TO_STRING_TAG] = returnThis;
              }
            }
            if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
              INCORRECT_VALUES_NAME = true;
              defaultIterator = function values2() {
                return nativeIterator.call(this);
              };
            }
            if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
              hide2(IterablePrototype, ITERATOR, defaultIterator);
            }
            Iterators[NAME] = defaultIterator;
            if (DEFAULT) {
              methods = {
                values: getIterationMethod(VALUES),
                keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                entries: getIterationMethod(ENTRIES)
              };
              if (FORCED)
                for (KEY in methods) {
                  if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                    redefine(IterablePrototype, KEY, methods[KEY]);
                  }
                }
              else
                $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
            }
            return methods;
          };
        },
        "./node_modules/core-js/internals/descriptors.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          module3.exports = !fails(function() {
            return Object.defineProperty({}, "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        },
        "./node_modules/core-js/internals/document-create-element.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var isObject = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          var document2 = global2.document;
          var exist = isObject(document2) && isObject(document2.createElement);
          module3.exports = function(it) {
            return exist ? document2.createElement(it) : {};
          };
        },
        "./node_modules/core-js/internals/enum-bug-keys.js": function(module3, exports2) {
          module3.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        },
        "./node_modules/core-js/internals/export.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var getOwnPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
          var hide2 = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var redefine = __webpack_require__("./node_modules/core-js/internals/redefine.js");
          var setGlobal = __webpack_require__("./node_modules/core-js/internals/set-global.js");
          var copyConstructorProperties = __webpack_require__("./node_modules/core-js/internals/copy-constructor-properties.js");
          var isForced = __webpack_require__("./node_modules/core-js/internals/is-forced.js");
          module3.exports = function(options, source) {
            var TARGET = options.target;
            var GLOBAL = options.global;
            var STATIC = options.stat;
            var FORCED, target, key, targetProperty, sourceProperty, descriptor;
            if (GLOBAL) {
              target = global2;
            } else if (STATIC) {
              target = global2[TARGET] || setGlobal(TARGET, {});
            } else {
              target = (global2[TARGET] || {}).prototype;
            }
            if (target)
              for (key in source) {
                sourceProperty = source[key];
                if (options.noTargetGet) {
                  descriptor = getOwnPropertyDescriptor(target, key);
                  targetProperty = descriptor && descriptor.value;
                } else
                  targetProperty = target[key];
                FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                if (!FORCED && targetProperty !== void 0) {
                  if (typeof sourceProperty === typeof targetProperty)
                    continue;
                  copyConstructorProperties(sourceProperty, targetProperty);
                }
                if (options.sham || targetProperty && targetProperty.sham) {
                  hide2(sourceProperty, "sham", true);
                }
                redefine(target, key, sourceProperty, options);
              }
          };
        },
        "./node_modules/core-js/internals/fails.js": function(module3, exports2) {
          module3.exports = function(exec) {
            try {
              return !!exec();
            } catch (error) {
              return true;
            }
          };
        },
        "./node_modules/core-js/internals/function-to-string.js": function(module3, exports2, __webpack_require__) {
          var shared = __webpack_require__("./node_modules/core-js/internals/shared.js");
          module3.exports = shared("native-function-to-string", Function.toString);
        },
        "./node_modules/core-js/internals/get-iterator-method.js": function(module3, exports2, __webpack_require__) {
          var classof = __webpack_require__("./node_modules/core-js/internals/classof.js");
          var Iterators = __webpack_require__("./node_modules/core-js/internals/iterators.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var ITERATOR = wellKnownSymbol("iterator");
          module3.exports = function(it) {
            if (it != void 0)
              return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
          };
        },
        "./node_modules/core-js/internals/global.js": function(module3, exports2, __webpack_require__) {
          (function(global2) {
            var O = "object";
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module3.exports = check(typeof globalThis == O && globalThis) || check(typeof window == O && window) || check(typeof self == O && self) || check(typeof global2 == O && global2) || Function("return this")();
          }).call(this, __webpack_require__("./node_modules/webpack/buildin/global.js"));
        },
        "./node_modules/core-js/internals/has.js": function(module3, exports2) {
          var hasOwnProperty = {}.hasOwnProperty;
          module3.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
          };
        },
        "./node_modules/core-js/internals/hidden-keys.js": function(module3, exports2) {
          module3.exports = {};
        },
        "./node_modules/core-js/internals/hide.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var definePropertyModule = __webpack_require__("./node_modules/core-js/internals/object-define-property.js");
          var createPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/create-property-descriptor.js");
          module3.exports = DESCRIPTORS ? function(object, key, value) {
            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
          } : function(object, key, value) {
            object[key] = value;
            return object;
          };
        },
        "./node_modules/core-js/internals/html.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var document2 = global2.document;
          module3.exports = document2 && document2.documentElement;
        },
        "./node_modules/core-js/internals/ie8-dom-define.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          var createElement = __webpack_require__("./node_modules/core-js/internals/document-create-element.js");
          module3.exports = !DESCRIPTORS && !fails(function() {
            return Object.defineProperty(createElement("div"), "a", {
              get: function() {
                return 7;
              }
            }).a != 7;
          });
        },
        "./node_modules/core-js/internals/indexed-object.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          var classof = __webpack_require__("./node_modules/core-js/internals/classof-raw.js");
          var split = "".split;
          module3.exports = fails(function() {
            return !Object("z").propertyIsEnumerable(0);
          }) ? function(it) {
            return classof(it) == "String" ? split.call(it, "") : Object(it);
          } : Object;
        },
        "./node_modules/core-js/internals/internal-state.js": function(module3, exports2, __webpack_require__) {
          var NATIVE_WEAK_MAP = __webpack_require__("./node_modules/core-js/internals/native-weak-map.js");
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var isObject = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          var hide2 = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var objectHas = __webpack_require__("./node_modules/core-js/internals/has.js");
          var sharedKey = __webpack_require__("./node_modules/core-js/internals/shared-key.js");
          var hiddenKeys = __webpack_require__("./node_modules/core-js/internals/hidden-keys.js");
          var WeakMap = global2.WeakMap;
          var set, get, has;
          var enforce = function(it) {
            return has(it) ? get(it) : set(it, {});
          };
          var getterFor = function(TYPE) {
            return function(it) {
              var state;
              if (!isObject(it) || (state = get(it)).type !== TYPE) {
                throw TypeError("Incompatible receiver, " + TYPE + " required");
              }
              return state;
            };
          };
          if (NATIVE_WEAK_MAP) {
            var store = new WeakMap();
            var wmget = store.get;
            var wmhas = store.has;
            var wmset = store.set;
            set = function(it, metadata) {
              wmset.call(store, it, metadata);
              return metadata;
            };
            get = function(it) {
              return wmget.call(store, it) || {};
            };
            has = function(it) {
              return wmhas.call(store, it);
            };
          } else {
            var STATE = sharedKey("state");
            hiddenKeys[STATE] = true;
            set = function(it, metadata) {
              hide2(it, STATE, metadata);
              return metadata;
            };
            get = function(it) {
              return objectHas(it, STATE) ? it[STATE] : {};
            };
            has = function(it) {
              return objectHas(it, STATE);
            };
          }
          module3.exports = {
            set,
            get,
            has,
            enforce,
            getterFor
          };
        },
        "./node_modules/core-js/internals/is-array-iterator-method.js": function(module3, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var Iterators = __webpack_require__("./node_modules/core-js/internals/iterators.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var ArrayPrototype = Array.prototype;
          module3.exports = function(it) {
            return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
          };
        },
        "./node_modules/core-js/internals/is-forced.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          var replacement = /#|\.prototype\./;
          var isForced = function(feature, detection) {
            var value = data[normalize(feature)];
            return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
          };
          var normalize = isForced.normalize = function(string) {
            return String(string).replace(replacement, ".").toLowerCase();
          };
          var data = isForced.data = {};
          var NATIVE = isForced.NATIVE = "N";
          var POLYFILL = isForced.POLYFILL = "P";
          module3.exports = isForced;
        },
        "./node_modules/core-js/internals/is-object.js": function(module3, exports2) {
          module3.exports = function(it) {
            return typeof it === "object" ? it !== null : typeof it === "function";
          };
        },
        "./node_modules/core-js/internals/is-pure.js": function(module3, exports2) {
          module3.exports = false;
        },
        "./node_modules/core-js/internals/iterators-core.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var getPrototypeOf = __webpack_require__("./node_modules/core-js/internals/object-get-prototype-of.js");
          var hide2 = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var IS_PURE = __webpack_require__("./node_modules/core-js/internals/is-pure.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var BUGGY_SAFARI_ITERATORS = false;
          var returnThis = function() {
            return this;
          };
          var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
          if ([].keys) {
            arrayIterator = [].keys();
            if (!("next" in arrayIterator))
              BUGGY_SAFARI_ITERATORS = true;
            else {
              PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
              if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                IteratorPrototype = PrototypeOfArrayIteratorPrototype;
            }
          }
          if (IteratorPrototype == void 0)
            IteratorPrototype = {};
          if (!IS_PURE && !has(IteratorPrototype, ITERATOR))
            hide2(IteratorPrototype, ITERATOR, returnThis);
          module3.exports = {
            IteratorPrototype,
            BUGGY_SAFARI_ITERATORS
          };
        },
        "./node_modules/core-js/internals/iterators.js": function(module3, exports2) {
          module3.exports = {};
        },
        "./node_modules/core-js/internals/native-symbol.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          module3.exports = !!Object.getOwnPropertySymbols && !fails(function() {
            return !String(Symbol());
          });
        },
        "./node_modules/core-js/internals/native-weak-map.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var nativeFunctionToString = __webpack_require__("./node_modules/core-js/internals/function-to-string.js");
          var WeakMap = global2.WeakMap;
          module3.exports = typeof WeakMap === "function" && /native code/.test(nativeFunctionToString.call(WeakMap));
        },
        "./node_modules/core-js/internals/object-create.js": function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          var defineProperties = __webpack_require__("./node_modules/core-js/internals/object-define-properties.js");
          var enumBugKeys = __webpack_require__("./node_modules/core-js/internals/enum-bug-keys.js");
          var hiddenKeys = __webpack_require__("./node_modules/core-js/internals/hidden-keys.js");
          var html = __webpack_require__("./node_modules/core-js/internals/html.js");
          var documentCreateElement = __webpack_require__("./node_modules/core-js/internals/document-create-element.js");
          var sharedKey = __webpack_require__("./node_modules/core-js/internals/shared-key.js");
          var IE_PROTO = sharedKey("IE_PROTO");
          var PROTOTYPE = "prototype";
          var Empty = function() {
          };
          var createDict = function() {
            var iframe = documentCreateElement("iframe");
            var length = enumBugKeys.length;
            var lt = "<";
            var script = "script";
            var gt = ">";
            var js = "java" + script + ":";
            var iframeDocument;
            iframe.style.display = "none";
            html.appendChild(iframe);
            iframe.src = String(js);
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(lt + script + gt + "document.F=Object" + lt + "/" + script + gt);
            iframeDocument.close();
            createDict = iframeDocument.F;
            while (length--)
              delete createDict[PROTOTYPE][enumBugKeys[length]];
            return createDict();
          };
          module3.exports = Object.create || function create(O, Properties) {
            var result;
            if (O !== null) {
              Empty[PROTOTYPE] = anObject(O);
              result = new Empty();
              Empty[PROTOTYPE] = null;
              result[IE_PROTO] = O;
            } else
              result = createDict();
            return Properties === void 0 ? result : defineProperties(result, Properties);
          };
          hiddenKeys[IE_PROTO] = true;
        },
        "./node_modules/core-js/internals/object-define-properties.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var definePropertyModule = __webpack_require__("./node_modules/core-js/internals/object-define-property.js");
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          var objectKeys = __webpack_require__("./node_modules/core-js/internals/object-keys.js");
          module3.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var keys = objectKeys(Properties);
            var length = keys.length;
            var i = 0;
            var key;
            while (length > i)
              definePropertyModule.f(O, key = keys[i++], Properties[key]);
            return O;
          };
        },
        "./node_modules/core-js/internals/object-define-property.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/internals/ie8-dom-define.js");
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          var toPrimitive = __webpack_require__("./node_modules/core-js/internals/to-primitive.js");
          var nativeDefineProperty = Object.defineProperty;
          exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE)
              try {
                return nativeDefineProperty(O, P, Attributes);
              } catch (error) {
              }
            if ("get" in Attributes || "set" in Attributes)
              throw TypeError("Accessors not supported");
            if ("value" in Attributes)
              O[P] = Attributes.value;
            return O;
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-descriptor.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var propertyIsEnumerableModule = __webpack_require__("./node_modules/core-js/internals/object-property-is-enumerable.js");
          var createPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/create-property-descriptor.js");
          var toIndexedObject = __webpack_require__("./node_modules/core-js/internals/to-indexed-object.js");
          var toPrimitive = __webpack_require__("./node_modules/core-js/internals/to-primitive.js");
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/internals/ie8-dom-define.js");
          var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
            O = toIndexedObject(O);
            P = toPrimitive(P, true);
            if (IE8_DOM_DEFINE)
              try {
                return nativeGetOwnPropertyDescriptor(O, P);
              } catch (error) {
              }
            if (has(O, P))
              return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-names.js": function(module3, exports2, __webpack_require__) {
          var internalObjectKeys = __webpack_require__("./node_modules/core-js/internals/object-keys-internal.js");
          var enumBugKeys = __webpack_require__("./node_modules/core-js/internals/enum-bug-keys.js");
          var hiddenKeys = enumBugKeys.concat("length", "prototype");
          exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return internalObjectKeys(O, hiddenKeys);
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-symbols.js": function(module3, exports2) {
          exports2.f = Object.getOwnPropertySymbols;
        },
        "./node_modules/core-js/internals/object-get-prototype-of.js": function(module3, exports2, __webpack_require__) {
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var toObject = __webpack_require__("./node_modules/core-js/internals/to-object.js");
          var sharedKey = __webpack_require__("./node_modules/core-js/internals/shared-key.js");
          var CORRECT_PROTOTYPE_GETTER = __webpack_require__("./node_modules/core-js/internals/correct-prototype-getter.js");
          var IE_PROTO = sharedKey("IE_PROTO");
          var ObjectPrototype = Object.prototype;
          module3.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
            O = toObject(O);
            if (has(O, IE_PROTO))
              return O[IE_PROTO];
            if (typeof O.constructor == "function" && O instanceof O.constructor) {
              return O.constructor.prototype;
            }
            return O instanceof Object ? ObjectPrototype : null;
          };
        },
        "./node_modules/core-js/internals/object-keys-internal.js": function(module3, exports2, __webpack_require__) {
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var toIndexedObject = __webpack_require__("./node_modules/core-js/internals/to-indexed-object.js");
          var arrayIncludes = __webpack_require__("./node_modules/core-js/internals/array-includes.js");
          var hiddenKeys = __webpack_require__("./node_modules/core-js/internals/hidden-keys.js");
          var arrayIndexOf = arrayIncludes(false);
          module3.exports = function(object, names) {
            var O = toIndexedObject(object);
            var i = 0;
            var result = [];
            var key;
            for (key in O)
              !has(hiddenKeys, key) && has(O, key) && result.push(key);
            while (names.length > i)
              if (has(O, key = names[i++])) {
                ~arrayIndexOf(result, key) || result.push(key);
              }
            return result;
          };
        },
        "./node_modules/core-js/internals/object-keys.js": function(module3, exports2, __webpack_require__) {
          var internalObjectKeys = __webpack_require__("./node_modules/core-js/internals/object-keys-internal.js");
          var enumBugKeys = __webpack_require__("./node_modules/core-js/internals/enum-bug-keys.js");
          module3.exports = Object.keys || function keys(O) {
            return internalObjectKeys(O, enumBugKeys);
          };
        },
        "./node_modules/core-js/internals/object-property-is-enumerable.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
          exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
            var descriptor = getOwnPropertyDescriptor(this, V);
            return !!descriptor && descriptor.enumerable;
          } : nativePropertyIsEnumerable;
        },
        "./node_modules/core-js/internals/object-set-prototype-of.js": function(module3, exports2, __webpack_require__) {
          var validateSetPrototypeOfArguments = __webpack_require__("./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");
          module3.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var correctSetter = false;
            var test = {};
            var setter;
            try {
              setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
              setter.call(test, []);
              correctSetter = test instanceof Array;
            } catch (error) {
            }
            return function setPrototypeOf(O, proto) {
              validateSetPrototypeOfArguments(O, proto);
              if (correctSetter)
                setter.call(O, proto);
              else
                O.__proto__ = proto;
              return O;
            };
          }() : void 0);
        },
        "./node_modules/core-js/internals/own-keys.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var getOwnPropertyNamesModule = __webpack_require__("./node_modules/core-js/internals/object-get-own-property-names.js");
          var getOwnPropertySymbolsModule = __webpack_require__("./node_modules/core-js/internals/object-get-own-property-symbols.js");
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          var Reflect2 = global2.Reflect;
          module3.exports = Reflect2 && Reflect2.ownKeys || function ownKeys(it) {
            var keys = getOwnPropertyNamesModule.f(anObject(it));
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
          };
        },
        "./node_modules/core-js/internals/path.js": function(module3, exports2, __webpack_require__) {
          module3.exports = __webpack_require__("./node_modules/core-js/internals/global.js");
        },
        "./node_modules/core-js/internals/redefine.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var shared = __webpack_require__("./node_modules/core-js/internals/shared.js");
          var hide2 = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var setGlobal = __webpack_require__("./node_modules/core-js/internals/set-global.js");
          var nativeFunctionToString = __webpack_require__("./node_modules/core-js/internals/function-to-string.js");
          var InternalStateModule = __webpack_require__("./node_modules/core-js/internals/internal-state.js");
          var getInternalState = InternalStateModule.get;
          var enforceInternalState = InternalStateModule.enforce;
          var TEMPLATE = String(nativeFunctionToString).split("toString");
          shared("inspectSource", function(it) {
            return nativeFunctionToString.call(it);
          });
          (module3.exports = function(O, key, value, options) {
            var unsafe = options ? !!options.unsafe : false;
            var simple = options ? !!options.enumerable : false;
            var noTargetGet = options ? !!options.noTargetGet : false;
            if (typeof value == "function") {
              if (typeof key == "string" && !has(value, "name"))
                hide2(value, "name", key);
              enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
            }
            if (O === global2) {
              if (simple)
                O[key] = value;
              else
                setGlobal(key, value);
              return;
            } else if (!unsafe) {
              delete O[key];
            } else if (!noTargetGet && O[key]) {
              simple = true;
            }
            if (simple)
              O[key] = value;
            else
              hide2(O, key, value);
          })(Function.prototype, "toString", function toString() {
            return typeof this == "function" && getInternalState(this).source || nativeFunctionToString.call(this);
          });
        },
        "./node_modules/core-js/internals/require-object-coercible.js": function(module3, exports2) {
          module3.exports = function(it) {
            if (it == void 0)
              throw TypeError("Can't call method on " + it);
            return it;
          };
        },
        "./node_modules/core-js/internals/set-global.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var hide2 = __webpack_require__("./node_modules/core-js/internals/hide.js");
          module3.exports = function(key, value) {
            try {
              hide2(global2, key, value);
            } catch (error) {
              global2[key] = value;
            }
            return value;
          };
        },
        "./node_modules/core-js/internals/set-to-string-tag.js": function(module3, exports2, __webpack_require__) {
          var defineProperty = __webpack_require__("./node_modules/core-js/internals/object-define-property.js").f;
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          module3.exports = function(it, TAG, STATIC) {
            if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
              defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
            }
          };
        },
        "./node_modules/core-js/internals/shared-key.js": function(module3, exports2, __webpack_require__) {
          var shared = __webpack_require__("./node_modules/core-js/internals/shared.js");
          var uid = __webpack_require__("./node_modules/core-js/internals/uid.js");
          var keys = shared("keys");
          module3.exports = function(key) {
            return keys[key] || (keys[key] = uid(key));
          };
        },
        "./node_modules/core-js/internals/shared.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var setGlobal = __webpack_require__("./node_modules/core-js/internals/set-global.js");
          var IS_PURE = __webpack_require__("./node_modules/core-js/internals/is-pure.js");
          var SHARED = "__core-js_shared__";
          var store = global2[SHARED] || setGlobal(SHARED, {});
          (module3.exports = function(key, value) {
            return store[key] || (store[key] = value !== void 0 ? value : {});
          })("versions", []).push({
            version: "3.1.3",
            mode: IS_PURE ? "pure" : "global",
            copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
          });
        },
        "./node_modules/core-js/internals/string-at.js": function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("./node_modules/core-js/internals/to-integer.js");
          var requireObjectCoercible = __webpack_require__("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(that, pos, CONVERT_TO_STRING) {
            var S = String(requireObjectCoercible(that));
            var position = toInteger(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size)
              return CONVERT_TO_STRING ? "" : void 0;
            first = S.charCodeAt(position);
            return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
          };
        },
        "./node_modules/core-js/internals/to-absolute-index.js": function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("./node_modules/core-js/internals/to-integer.js");
          var max2 = Math.max;
          var min2 = Math.min;
          module3.exports = function(index, length) {
            var integer = toInteger(index);
            return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
          };
        },
        "./node_modules/core-js/internals/to-indexed-object.js": function(module3, exports2, __webpack_require__) {
          var IndexedObject = __webpack_require__("./node_modules/core-js/internals/indexed-object.js");
          var requireObjectCoercible = __webpack_require__("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(it) {
            return IndexedObject(requireObjectCoercible(it));
          };
        },
        "./node_modules/core-js/internals/to-integer.js": function(module3, exports2) {
          var ceil = Math.ceil;
          var floor = Math.floor;
          module3.exports = function(argument) {
            return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
          };
        },
        "./node_modules/core-js/internals/to-length.js": function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("./node_modules/core-js/internals/to-integer.js");
          var min2 = Math.min;
          module3.exports = function(argument) {
            return argument > 0 ? min2(toInteger(argument), 9007199254740991) : 0;
          };
        },
        "./node_modules/core-js/internals/to-object.js": function(module3, exports2, __webpack_require__) {
          var requireObjectCoercible = __webpack_require__("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(argument) {
            return Object(requireObjectCoercible(argument));
          };
        },
        "./node_modules/core-js/internals/to-primitive.js": function(module3, exports2, __webpack_require__) {
          var isObject = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          module3.exports = function(it, S) {
            if (!isObject(it))
              return it;
            var fn2, val;
            if (S && typeof (fn2 = it.toString) == "function" && !isObject(val = fn2.call(it)))
              return val;
            if (typeof (fn2 = it.valueOf) == "function" && !isObject(val = fn2.call(it)))
              return val;
            if (!S && typeof (fn2 = it.toString) == "function" && !isObject(val = fn2.call(it)))
              return val;
            throw TypeError("Can't convert object to primitive value");
          };
        },
        "./node_modules/core-js/internals/uid.js": function(module3, exports2) {
          var id = 0;
          var postfix = Math.random();
          module3.exports = function(key) {
            return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + postfix).toString(36));
          };
        },
        "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": function(module3, exports2, __webpack_require__) {
          var isObject = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          module3.exports = function(O, proto) {
            anObject(O);
            if (!isObject(proto) && proto !== null) {
              throw TypeError("Can't set " + String(proto) + " as a prototype");
            }
          };
        },
        "./node_modules/core-js/internals/well-known-symbol.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var shared = __webpack_require__("./node_modules/core-js/internals/shared.js");
          var uid = __webpack_require__("./node_modules/core-js/internals/uid.js");
          var NATIVE_SYMBOL = __webpack_require__("./node_modules/core-js/internals/native-symbol.js");
          var Symbol2 = global2.Symbol;
          var store = shared("wks");
          module3.exports = function(name) {
            return store[name] || (store[name] = NATIVE_SYMBOL && Symbol2[name] || (NATIVE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
          };
        },
        "./node_modules/core-js/modules/es.array.from.js": function(module3, exports2, __webpack_require__) {
          var $ = __webpack_require__("./node_modules/core-js/internals/export.js");
          var from = __webpack_require__("./node_modules/core-js/internals/array-from.js");
          var checkCorrectnessOfIteration = __webpack_require__("./node_modules/core-js/internals/check-correctness-of-iteration.js");
          var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
            Array.from(iterable);
          });
          $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
            from
          });
        },
        "./node_modules/core-js/modules/es.string.iterator.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var codePointAt = __webpack_require__("./node_modules/core-js/internals/string-at.js");
          var InternalStateModule = __webpack_require__("./node_modules/core-js/internals/internal-state.js");
          var defineIterator = __webpack_require__("./node_modules/core-js/internals/define-iterator.js");
          var STRING_ITERATOR = "String Iterator";
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
          defineIterator(String, "String", function(iterated) {
            setInternalState(this, {
              type: STRING_ITERATOR,
              string: String(iterated),
              index: 0
            });
          }, function next() {
            var state = getInternalState(this);
            var string = state.string;
            var index = state.index;
            var point;
            if (index >= string.length)
              return { value: void 0, done: true };
            point = codePointAt(string, index, true);
            state.index += point.length;
            return { value: point, done: false };
          });
        },
        "./node_modules/webpack/buildin/global.js": function(module3, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || Function("return this")() || (1, eval)("this");
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module3.exports = g;
        },
        "./src/default-attrs.json": function(module3) {
          module3.exports = { "xmlns": "http://www.w3.org/2000/svg", "width": 24, "height": 24, "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "stroke-width": 2, "stroke-linecap": "round", "stroke-linejoin": "round" };
        },
        "./src/icon.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _dedupe = __webpack_require__("./node_modules/classnames/dedupe.js");
          var _dedupe2 = _interopRequireDefault(_dedupe);
          var _defaultAttrs = __webpack_require__("./src/default-attrs.json");
          var _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance9, Constructor) {
            if (!(instance9 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Icon = function() {
            function Icon2(name, contents) {
              var tags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
              _classCallCheck(this, Icon2);
              this.name = name;
              this.contents = contents;
              this.tags = tags;
              this.attrs = _extends({}, _defaultAttrs2.default, { class: "feather feather-" + name });
            }
            _createClass(Icon2, [{
              key: "toSvg",
              value: function toSvg() {
                var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });
                return "<svg " + attrsToString(combinedAttrs) + ">" + this.contents + "</svg>";
              }
            }, {
              key: "toString",
              value: function toString() {
                return this.contents;
              }
            }]);
            return Icon2;
          }();
          function attrsToString(attrs) {
            return Object.keys(attrs).map(function(key) {
              return key + '="' + attrs[key] + '"';
            }).join(" ");
          }
          exports2.default = Icon;
        },
        "./src/icons.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _icon = __webpack_require__("./src/icon.js");
          var _icon2 = _interopRequireDefault(_icon);
          var _icons = __webpack_require__("./dist/icons.json");
          var _icons2 = _interopRequireDefault(_icons);
          var _tags = __webpack_require__("./src/tags.json");
          var _tags2 = _interopRequireDefault(_tags);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = Object.keys(_icons2.default).map(function(key) {
            return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);
          }).reduce(function(object, icon) {
            object[icon.name] = icon;
            return object;
          }, {});
        },
        "./src/index.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var _icons = __webpack_require__("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          var _toSvg = __webpack_require__("./src/to-svg.js");
          var _toSvg2 = _interopRequireDefault(_toSvg);
          var _replace = __webpack_require__("./src/replace.js");
          var _replace2 = _interopRequireDefault(_replace);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          module3.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };
        },
        "./src/replace.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _dedupe = __webpack_require__("./node_modules/classnames/dedupe.js");
          var _dedupe2 = _interopRequireDefault(_dedupe);
          var _icons = __webpack_require__("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function replace() {
            var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (typeof document === "undefined") {
              throw new Error("`feather.replace()` only works in a browser environment.");
            }
            var elementsToReplace = document.querySelectorAll("[data-feather]");
            Array.from(elementsToReplace).forEach(function(element2) {
              return replaceElement(element2, attrs);
            });
          }
          function replaceElement(element2) {
            var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var elementAttrs = getAttrs(element2);
            var name = elementAttrs["data-feather"];
            delete elementAttrs["data-feather"];
            var svgString = _icons2.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));
            var svgDocument = new DOMParser().parseFromString(svgString, "image/svg+xml");
            var svgElement = svgDocument.querySelector("svg");
            element2.parentNode.replaceChild(svgElement, element2);
          }
          function getAttrs(element2) {
            return Array.from(element2.attributes).reduce(function(attrs, attr2) {
              attrs[attr2.name] = attr2.value;
              return attrs;
            }, {});
          }
          exports2.default = replace;
        },
        "./src/tags.json": function(module3) {
          module3.exports = { "activity": ["pulse", "health", "action", "motion"], "airplay": ["stream", "cast", "mirroring"], "alert-circle": ["warning", "alert", "danger"], "alert-octagon": ["warning", "alert", "danger"], "alert-triangle": ["warning", "alert", "danger"], "align-center": ["text alignment", "center"], "align-justify": ["text alignment", "justified"], "align-left": ["text alignment", "left"], "align-right": ["text alignment", "right"], "anchor": [], "archive": ["index", "box"], "at-sign": ["mention", "at", "email", "message"], "award": ["achievement", "badge"], "aperture": ["camera", "photo"], "bar-chart": ["statistics", "diagram", "graph"], "bar-chart-2": ["statistics", "diagram", "graph"], "battery": ["power", "electricity"], "battery-charging": ["power", "electricity"], "bell": ["alarm", "notification", "sound"], "bell-off": ["alarm", "notification", "silent"], "bluetooth": ["wireless"], "book-open": ["read", "library"], "book": ["read", "dictionary", "booklet", "magazine", "library"], "bookmark": ["read", "clip", "marker", "tag"], "box": ["cube"], "briefcase": ["work", "bag", "baggage", "folder"], "calendar": ["date"], "camera": ["photo"], "cast": ["chromecast", "airplay"], "chevron-down": ["expand"], "chevron-up": ["collapse"], "circle": ["off", "zero", "record"], "clipboard": ["copy"], "clock": ["time", "watch", "alarm"], "cloud-drizzle": ["weather", "shower"], "cloud-lightning": ["weather", "bolt"], "cloud-rain": ["weather"], "cloud-snow": ["weather", "blizzard"], "cloud": ["weather"], "codepen": ["logo"], "codesandbox": ["logo"], "code": ["source", "programming"], "coffee": ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"], "columns": ["layout"], "command": ["keyboard", "cmd", "terminal", "prompt"], "compass": ["navigation", "safari", "travel", "direction"], "copy": ["clone", "duplicate"], "corner-down-left": ["arrow", "return"], "corner-down-right": ["arrow"], "corner-left-down": ["arrow"], "corner-left-up": ["arrow"], "corner-right-down": ["arrow"], "corner-right-up": ["arrow"], "corner-up-left": ["arrow"], "corner-up-right": ["arrow"], "cpu": ["processor", "technology"], "credit-card": ["purchase", "payment", "cc"], "crop": ["photo", "image"], "crosshair": ["aim", "target"], "database": ["storage", "memory"], "delete": ["remove"], "disc": ["album", "cd", "dvd", "music"], "dollar-sign": ["currency", "money", "payment"], "droplet": ["water"], "edit": ["pencil", "change"], "edit-2": ["pencil", "change"], "edit-3": ["pencil", "change"], "eye": ["view", "watch"], "eye-off": ["view", "watch", "hide", "hidden"], "external-link": ["outbound"], "facebook": ["logo", "social"], "fast-forward": ["music"], "figma": ["logo", "design", "tool"], "file-minus": ["delete", "remove", "erase"], "file-plus": ["add", "create", "new"], "file-text": ["data", "txt", "pdf"], "film": ["movie", "video"], "filter": ["funnel", "hopper"], "flag": ["report"], "folder-minus": ["directory"], "folder-plus": ["directory"], "folder": ["directory"], "framer": ["logo", "design", "tool"], "frown": ["emoji", "face", "bad", "sad", "emotion"], "gift": ["present", "box", "birthday", "party"], "git-branch": ["code", "version control"], "git-commit": ["code", "version control"], "git-merge": ["code", "version control"], "git-pull-request": ["code", "version control"], "github": ["logo", "version control"], "gitlab": ["logo", "version control"], "globe": ["world", "browser", "language", "translate"], "hard-drive": ["computer", "server", "memory", "data"], "hash": ["hashtag", "number", "pound"], "headphones": ["music", "audio", "sound"], "heart": ["like", "love", "emotion"], "help-circle": ["question mark"], "hexagon": ["shape", "node.js", "logo"], "home": ["house", "living"], "image": ["picture"], "inbox": ["email"], "instagram": ["logo", "camera"], "key": ["password", "login", "authentication", "secure"], "layers": ["stack"], "layout": ["window", "webpage"], "life-bouy": ["help", "life ring", "support"], "link": ["chain", "url"], "link-2": ["chain", "url"], "linkedin": ["logo", "social media"], "list": ["options"], "lock": ["security", "password", "secure"], "log-in": ["sign in", "arrow", "enter"], "log-out": ["sign out", "arrow", "exit"], "mail": ["email", "message"], "map-pin": ["location", "navigation", "travel", "marker"], "map": ["location", "navigation", "travel"], "maximize": ["fullscreen"], "maximize-2": ["fullscreen", "arrows", "expand"], "meh": ["emoji", "face", "neutral", "emotion"], "menu": ["bars", "navigation", "hamburger"], "message-circle": ["comment", "chat"], "message-square": ["comment", "chat"], "mic-off": ["record", "sound", "mute"], "mic": ["record", "sound", "listen"], "minimize": ["exit fullscreen", "close"], "minimize-2": ["exit fullscreen", "arrows", "close"], "minus": ["subtract"], "monitor": ["tv", "screen", "display"], "moon": ["dark", "night"], "more-horizontal": ["ellipsis"], "more-vertical": ["ellipsis"], "mouse-pointer": ["arrow", "cursor"], "move": ["arrows"], "music": ["note"], "navigation": ["location", "travel"], "navigation-2": ["location", "travel"], "octagon": ["stop"], "package": ["box", "container"], "paperclip": ["attachment"], "pause": ["music", "stop"], "pause-circle": ["music", "audio", "stop"], "pen-tool": ["vector", "drawing"], "percent": ["discount"], "phone-call": ["ring"], "phone-forwarded": ["call"], "phone-incoming": ["call"], "phone-missed": ["call"], "phone-off": ["call", "mute"], "phone-outgoing": ["call"], "phone": ["call"], "play": ["music", "start"], "pie-chart": ["statistics", "diagram"], "play-circle": ["music", "start"], "plus": ["add", "new"], "plus-circle": ["add", "new"], "plus-square": ["add", "new"], "pocket": ["logo", "save"], "power": ["on", "off"], "printer": ["fax", "office", "device"], "radio": ["signal"], "refresh-cw": ["synchronise", "arrows"], "refresh-ccw": ["arrows"], "repeat": ["loop", "arrows"], "rewind": ["music"], "rotate-ccw": ["arrow"], "rotate-cw": ["arrow"], "rss": ["feed", "subscribe"], "save": ["floppy disk"], "scissors": ["cut"], "search": ["find", "magnifier", "magnifying glass"], "send": ["message", "mail", "email", "paper airplane", "paper aeroplane"], "settings": ["cog", "edit", "gear", "preferences"], "share-2": ["network", "connections"], "shield": ["security", "secure"], "shield-off": ["security", "insecure"], "shopping-bag": ["ecommerce", "cart", "purchase", "store"], "shopping-cart": ["ecommerce", "cart", "purchase", "store"], "shuffle": ["music"], "skip-back": ["music"], "skip-forward": ["music"], "slack": ["logo"], "slash": ["ban", "no"], "sliders": ["settings", "controls"], "smartphone": ["cellphone", "device"], "smile": ["emoji", "face", "happy", "good", "emotion"], "speaker": ["audio", "music"], "star": ["bookmark", "favorite", "like"], "stop-circle": ["media", "music"], "sun": ["brightness", "weather", "light"], "sunrise": ["weather", "time", "morning", "day"], "sunset": ["weather", "time", "evening", "night"], "tablet": ["device"], "tag": ["label"], "target": ["logo", "bullseye"], "terminal": ["code", "command line", "prompt"], "thermometer": ["temperature", "celsius", "fahrenheit", "weather"], "thumbs-down": ["dislike", "bad", "emotion"], "thumbs-up": ["like", "good", "emotion"], "toggle-left": ["on", "off", "switch"], "toggle-right": ["on", "off", "switch"], "tool": ["settings", "spanner"], "trash": ["garbage", "delete", "remove", "bin"], "trash-2": ["garbage", "delete", "remove", "bin"], "triangle": ["delta"], "truck": ["delivery", "van", "shipping", "transport", "lorry"], "tv": ["television", "stream"], "twitch": ["logo"], "twitter": ["logo", "social"], "type": ["text"], "umbrella": ["rain", "weather"], "unlock": ["security"], "user-check": ["followed", "subscribed"], "user-minus": ["delete", "remove", "unfollow", "unsubscribe"], "user-plus": ["new", "add", "create", "follow", "subscribe"], "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"], "user": ["person", "account"], "users": ["group"], "video-off": ["camera", "movie", "film"], "video": ["camera", "movie", "film"], "voicemail": ["phone"], "volume": ["music", "sound", "mute"], "volume-1": ["music", "sound"], "volume-2": ["music", "sound"], "volume-x": ["music", "sound", "mute"], "watch": ["clock", "time"], "wifi-off": ["disabled"], "wifi": ["connection", "signal", "wireless"], "wind": ["weather", "air"], "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"], "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"], "x-square": ["cancel", "close", "delete", "remove", "times", "clear"], "x": ["cancel", "close", "delete", "remove", "times", "clear"], "youtube": ["logo", "video", "play"], "zap-off": ["flash", "camera", "lightning"], "zap": ["flash", "camera", "lightning"], "zoom-in": ["magnifying glass"], "zoom-out": ["magnifying glass"] };
        },
        "./src/to-svg.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _icons = __webpack_require__("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function toSvg(name) {
            var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.");
            if (!name) {
              throw new Error("The required `key` (icon name) parameter is missing.");
            }
            if (!_icons2.default[name]) {
              throw new Error("No icon matching '" + name + "'. See the complete list of icons at https://feathericons.com");
            }
            return _icons2.default[name].toSvg(attrs);
          }
          exports2.default = toSvg;
        },
        0: function(module3, exports2, __webpack_require__) {
          __webpack_require__("./node_modules/core-js/es/array/from.js");
          module3.exports = __webpack_require__("./src/index.js");
        }
      });
    });
  }
});

// node_modules/lodash.groupby/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.groupby/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values2) {
      var index = -1, length = values2 ? values2.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values2[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func2 = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func2(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString.call(func2);
        } catch (e) {
        }
        try {
          return func2 + "";
        } catch (e) {
        }
      }
      return "";
    }
    var groupBy5 = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });
    function memoize(func2, resolver) {
      if (typeof func2 != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func2.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = groupBy5;
  }
});

// node_modules/lodash.mergewith/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.mergewith/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func2, thisArg, args) {
      switch (args.length) {
        case 0:
          return func2.call(thisArg);
        case 1:
          return func2.call(thisArg, args[0]);
        case 2:
          return func2.call(thisArg, args[0], args[1]);
        case 3:
          return func2.call(thisArg, args[0], args[1], args[2]);
      }
      return func2.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func2 = getNative(Object, "defineProperty");
        func2({}, "", {});
        return func2;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func2, start2) {
      return setToString(overRest(func2, start2, identity), func2 + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func2, string) {
      return defineProperty(func2, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func2, start2, transform) {
      start2 = nativeMax(start2 === void 0 ? func2.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = transform(array);
        return apply(func2, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func2) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func2.apply(void 0, arguments);
      };
    }
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString.call(func2);
        } catch (e) {
        }
        try {
          return func2 + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module2.exports = mergeWith2;
  }
});

// node_modules/lodash.keyby/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.keyby/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values2) {
      var index = -1, length = values2 ? values2.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values2[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func2 = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func2(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString.call(func2);
        } catch (e) {
        }
        try {
          return func2 + "";
        } catch (e) {
        }
      }
      return "";
    }
    var keyBy2 = createAggregator(function(result, value, key) {
      result[key] = value;
    });
    function memoize(func2, resolver) {
      if (typeof func2 != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func2.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = keyBy2;
  }
});

// node_modules/lodash.values/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.values/index.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values2(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = values2;
  }
});

// node_modules/lodash.sortby/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.sortby/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func2, thisArg, args) {
      switch (args.length) {
        case 0:
          return func2.call(thisArg);
        case 1:
          return func2.call(thisArg, args[0]);
        case 2:
          return func2.call(thisArg, args[0], args[1]);
        case 3:
          return func2.call(thisArg, args[0], args[1], args[2]);
      }
      return func2.apply(thisArg, args);
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values2) {
      var index = -1, length = values2.length, offset2 = array.length;
      while (++index < length) {
        array[offset2 + index] = values2[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values2) {
      var index = -1, length = values2 ? values2.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values2[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseRest(func2, start2) {
      start2 = nativeMax(start2 === void 0 ? func2.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = array;
        return apply(func2, this, otherArgs);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order2 = orders[index];
          return result * (order2 == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString.call(func2);
        } catch (e) {
        }
        try {
          return func2 + "";
        } catch (e) {
        }
      }
      return "";
    }
    var sortBy3 = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function memoize(func2, resolver) {
      if (typeof func2 != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func2.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = sortBy3;
  }
});

// src/main.ts
__export(exports, {
  default: () => RssReaderPlugin
});
var import_obsidian28 = __toModule(require("obsidian"));

// src/settings/settings.ts
var DEFAULT_SETTINGS = Object.freeze({
  feeds: [],
  updateTime: 60,
  filtered: [{
    name: "Favorites",
    read: true,
    unread: true,
    filterTags: [],
    filterFolders: [],
    filterFeeds: [],
    ignoreTags: [],
    ignoreFeeds: [],
    ignoreFolders: [],
    favorites: true,
    sortOrder: "ALPHABET_NORMAL"
  }],
  saveLocation: "default",
  displayStyle: "cards",
  saveLocationFolder: "",
  items: [],
  dateFormat: "YYYY-MM-DDTHH:mm:SS",
  template: "---\nlink: {{link}}\nauthor: {{author}}\npublished: {{published}}\ntags: [{{tags:,}}]\n---\n# Highlights\n{{highlights}}\n\n---\n# {{title}}\n{{content}}",
  pasteTemplate: "## {{title}}\n{{content}}",
  askForFilename: true,
  defaultFilename: "{{title}}",
  autoSync: false,
  hotkeys: {
    create: "n",
    paste: "v",
    copy: "c",
    favorite: "f",
    read: "r",
    tags: "t",
    open: "o",
    tts: "s",
    previous: "ArrowLeft",
    next: "ArrowRight"
  },
  folded: [],
  renamedText: {
    filtered_folders: "",
    folders: "",
    no_folder: ""
  },
  displayMedia: true
});

// src/view/ViewLoader.ts
var import_obsidian16 = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance9, create_fragment9, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance9 ? instance9(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment9 ? create_fragment9($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start2 = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/stores.ts
var configuredFeedsStore = writable([]);
var filteredStore = writable([]);
var settingsStore = writable(DEFAULT_SETTINGS);
var feedsStore = writable([]);
var sortedFeedsStore = writable();
var filteredItemsStore = writable();
var foldedState = writable();
var tagsStore = writable();
var folderStore = writable();

// src/view/IconComponent.svelte
var import_obsidian = __toModule(require("obsidian"));
function create_if_block(ctx) {
  let span;
  let icon_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(icon_action = ctx[1].call(null, span, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (icon_action && is_function(icon_action.update) && dirty & 1)
        icon_action.update.call(null, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let if_block_anchor;
  let if_block = ctx[0].length > 0 && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { iconName = "" } = $$props;
  const icon = (node, icon2) => {
    (0, import_obsidian.setIcon)(node, icon2);
  };
  $$self.$$set = ($$props2) => {
    if ("iconName" in $$props2)
      $$invalidate(0, iconName = $$props2.iconName);
  };
  return [iconName, icon];
}
var IconComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { iconName: 0 });
  }
};
var IconComponent_default = IconComponent;

// src/parser/rssParser.ts
var import_obsidian2 = __toModule(require("obsidian"));
var import_ts_md5 = __toModule(require_md5());
function getElementByName(element2, name) {
  let value;
  if (typeof element2.getElementsByTagName !== "function" && typeof element2.getElementsByTagNameNS !== "function") {
    return;
  }
  if (name.includes(":")) {
    const [namespace, tag] = name.split(":");
    const namespaceUri = element2.lookupNamespaceURI(namespace);
    const byNamespace = element2.getElementsByTagNameNS(namespaceUri, tag);
    if (byNamespace.length > 0) {
      value = byNamespace[0].childNodes[0];
    } else {
      const tmp = element2.getElementsByTagName(name);
      if (tmp.length > 0) {
        if (tmp[0].childNodes.length === 0) {
          value = tmp[0];
        } else {
          const node = tmp[0].childNodes[0];
          if (node !== void 0) {
            value = node;
          }
        }
      }
    }
  } else if (name.includes(".")) {
    const [prefix, tag] = name.split(".");
    if (element2.getElementsByTagName(prefix).length > 0) {
      const nodes = Array.from(element2.getElementsByTagName(prefix)[0].childNodes);
      nodes.forEach((node) => {
        if (node.nodeName == tag) {
          value = node;
        }
      });
    }
  } else if (element2.getElementsByTagName(name).length > 0) {
    if (element2.getElementsByTagName(name)[0].childNodes.length == 0) {
      value = element2.getElementsByTagName(name)[0];
    } else {
      const node = element2.getElementsByTagName(name)[0].childNodes[0];
      if (node !== void 0)
        value = node;
    }
  }
  return value;
}
function getContent(element2, names) {
  let value;
  for (const name of names) {
    if (name.includes("#")) {
      const [elementName, attr2] = name.split("#");
      const data = getElementByName(element2, elementName);
      if (data) {
        if (data.nodeName === elementName) {
          const tmp = data.getAttribute(attr2);
          if (tmp.length > 0) {
            value = tmp;
          }
        }
      }
    } else {
      const data = getElementByName(element2, name);
      if (data) {
        if (data.wholeText && data.wholeText.length > 0) {
          value = data.wholeText;
        }
        if (!value && data.nodeValue && data.nodeValue.length > 0) {
          value = data.nodeValue;
        }
        if (!value && data.innerHTML && data.innerHTML.length > 0) {
          value = data.innerHTML;
        }
      }
    }
  }
  if (value === void 0) {
    return "";
  }
  return value;
}
function buildItem(element2) {
  return {
    title: getContent(element2, ["title"]),
    description: getContent(element2, ["content", "content:encoded", "itunes:summary", "description", "summary", "media:description"]),
    content: getContent(element2, ["itunes:summary", "description", "summary", "media:description", "content", "content:encoded", "ns0:encoded"]),
    category: getContent(element2, ["category"]),
    link: getContent(element2, ["link", "link#href"]),
    creator: getContent(element2, ["creator", "dc:creator", "author", "author.name"]),
    pubDate: getContent(element2, ["pubDate", "published", "updated", "dc:date"]),
    enclosure: getContent(element2, ["enclosure#url", "yt:videoId"]),
    enclosureType: getContent(element2, ["enclosure#type"]),
    image: getContent(element2, ["enclosure#url", "media:content#url", "itunes:image#href", "media:thumbnail#url"]),
    id: getContent(element2, ["id"]),
    language: null,
    folder: null,
    feed: null,
    read: null,
    favorite: null,
    created: null,
    tags: [],
    hash: null,
    highlights: []
  };
}
function getAllItems(doc) {
  const items = [];
  if (doc.getElementsByTagName("item")) {
    for (const elementsByTagNameKey in doc.getElementsByTagName("item")) {
      const entry = doc.getElementsByTagName("item")[elementsByTagNameKey];
      items.push(entry);
    }
  }
  if (doc.getElementsByTagName("entry")) {
    for (const elementsByTagNameKey in doc.getElementsByTagName("entry")) {
      const entry = doc.getElementsByTagName("entry")[elementsByTagNameKey];
      items.push(entry);
    }
  }
  return items;
}
function requestFeed(feed) {
  return __async(this, null, function* () {
    return yield (0, import_obsidian2.request)({ url: feed.url });
  });
}
function getFeedItems(feed) {
  return __async(this, null, function* () {
    let data;
    try {
      const rawData = yield requestFeed(feed);
      data = new window.DOMParser().parseFromString(rawData, "text/xml");
    } catch (e) {
      console.error(e);
      return Promise.resolve(void 0);
    }
    const items = [];
    const rawItems = getAllItems(data);
    const language = getContent(data, ["language"]).substr(0, 2);
    rawItems.forEach((rawItem) => {
      const item = buildItem(rawItem);
      if (item.title !== void 0 && item.title.length !== 0) {
        item.folder = feed.folder;
        item.feed = feed.name;
        item.read = false;
        item.favorite = false;
        item.created = false;
        item.language = language;
        item.hash = new import_ts_md5.Md5().appendStr(item.title).appendStr(item.folder).appendStr(item.link).end();
        if (!item.image && feed.url.includes("youtube.com/feeds")) {
          item.image = "https://i3.ytimg.com/vi/" + item.id.split(":")[2] + "/hqdefault.jpg";
        }
        items.push(item);
      }
    });
    const image = getContent(data, ["image", "image.url", "icon"]);
    const content = {
      title: getContent(data, ["title"]),
      subtitle: getContent(data, ["subtitle"]),
      link: getContent(data, ["link"]),
      image: image ? image.replace(/^\/|\/$/g, "") : null,
      description: getContent(data, ["description"]),
      items,
      folder: feed.folder,
      name: feed.name,
      language,
      hash: ""
    };
    return Promise.resolve(content);
  });
}

// src/consts.ts
var VIEW_ID = "RSS_FEED";
var FILE_NAME_REGEX = /["\/<>:|?]/gm;
var TAG_REGEX = /([\p{Letter}\p{Emoji_Presentation}\p{Number}\/_-]+)/u;
var NUMBER_REGEX = /^[0-9]*$/gm;
function sanitizeHTMLToDom(html) {
  return window.DOMPurify.sanitize(html, {
    ALLOW_UNKNOWN_PROTOCOLS: true,
    RETURN_DOM_FRAGMENT: true,
    RETURN_DOM_IMPORT: true,
    FORBID_TAGS: ["style"],
    ADD_TAGS: ["iframe"],
    ADD_ATTR: ["frameborder", "allowfullscreen", "allow", "aria-label-position"]
  });
}
function isValidHttpUrl(string) {
  let url;
  try {
    url = new URL(string);
  } catch (_) {
    return false;
  }
  return url.protocol === "http:" || url.protocol === "https:";
}

// src/view/HtmlTooltip.svelte
function create_if_block2(ctx) {
  let p;
  let html_action;
  let mounted;
  let dispose;
  return {
    c() {
      p = element("p");
      attr(p, "class", "tooltiptext");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      if (!mounted) {
        dispose = action_destroyer(html_action = ctx[1].call(null, p, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (html_action && is_function(html_action.update) && dirty & 1)
        html_action.update.call(null, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let if_block = ctx[0].length > 0 && create_if_block2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { content = "" } = $$props;
  const html = (node, content2) => {
    node.append(sanitizeHTMLToDom(content2));
  };
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
  };
  return [content, html];
}
var HtmlTooltip = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { content: 0 });
  }
};
var HtmlTooltip_default = HtmlTooltip;

// src/modals/ItemModal.ts
var import_obsidian10 = __toModule(require("obsidian"));

// src/functions.ts
var import_obsidian6 = __toModule(require("obsidian"));

// src/modals/TextInputPrompt.ts
var import_obsidian4 = __toModule(require("obsidian"));

// src/modals/BaseModal.ts
var import_obsidian3 = __toModule(require("obsidian"));
var BaseModal = class extends import_obsidian3.Modal {
  setValidationError(input, message) {
    input.inputEl.addClass("is-invalid");
    if (message) {
      input.inputEl.parentElement.addClasses([
        "has-invalid-message",
        "unset-align-items"
      ]);
      input.inputEl.parentElement.parentElement.addClass(".unset-align-items");
      let mDiv = input.inputEl.parentElement.querySelector(".invalid-feedback");
      if (!mDiv) {
        mDiv = createDiv({ cls: "invalid-feedback" });
      }
      mDiv.innerText = message;
      mDiv.insertAfter(input.inputEl);
    }
  }
  removeValidationError(input) {
    input.inputEl.removeClass("is-invalid");
    input.inputEl.parentElement.removeClasses([
      "has-invalid-message",
      "unset-align-items"
    ]);
    input.inputEl.parentElement.parentElement.removeClass(".unset-align-items");
    if (input.inputEl.parentElement.querySelector(".invalid-feedback")) {
      input.inputEl.parentElement.removeChild(input.inputEl.parentElement.querySelector(".invalid-feedback"));
    }
  }
};

// src/l10n/locales/en.ts
var en_default = {
  testingValue: "",
  testingInserts: "",
  RSS_Reader: "RSS Reader",
  RSS_Feeds: "RSS Feeds",
  open: "Open",
  refresh_feeds: "Refresh feeds",
  create_all: "Create all",
  mark_all_as_read: "Mark all as read",
  add_tags_to_all: "Add tags to all entries",
  filtered_folders: "Filtered Folders",
  folders: "Folders",
  folder: "Folder",
  feeds: "Feeds",
  create_note: "create new note",
  paste_to_note: "paste to current note",
  copy_to_clipboard: "copy to clipboard",
  open_browser: "open in browser",
  edit_tags: "edit tags",
  mark_as_read: "Mark as read",
  mark_as_unread: "Mark as unread",
  mark_as_favorite: "mark as favorite",
  remove_from_favorites: "remove from favorites",
  read_article_tts: "read article with TTS",
  next: "next",
  previous: "previous",
  mark_as_read_unread: "mark as read/unread",
  mark_as_favorite_remove: "mark as favorite/remove from favorites",
  marked_as_read: "marked item as read",
  marked_as_unread: "marked item as unread",
  removed_from_favorites: "removed item from favorites",
  added_to_favorites: "marked item as favorite",
  read: "read",
  unread: "unread",
  favorites: "Favorites",
  favorite: "Favorite",
  tags: "Tags",
  tag: "Tag",
  save: "Save",
  cancel: "Cancel",
  delete: "Delete",
  edit: "Edit",
  reset: "restore default",
  fix_errors: "Please fix errors before saving.",
  add_new: "Add new",
  add_new_feed: "Add new feed",
  feed_already_configured: "you already have a feed configured with that url",
  no_folder: "No folder",
  name: "Name",
  name_help: "What do you want this feed to show up as?",
  url_help: "What is the URL to the feed?",
  folder_help: "What do you categorize this feed as?",
  invalid_name: "you need to specify a name",
  invalid_url: "this url is not valid",
  invalid_feed: "This feed does not have any entries",
  filter_tags: "All articles with tags",
  filter_unread: "All unread articles(from folders)",
  filter_read: "All read articles(from folders)",
  filter_favorites: "Favorites(from folders)",
  sort_date_newest: "Publication date (new to old)",
  sort_date_oldest: "Publication date (old to new)",
  sort_alphabet_normal: "Name (A to Z)",
  sort_alphabet_inverted: "Name (Z to A)",
  sort: "Order by",
  filter_name_help: "What do you want this filter to show up as?",
  filter_type: "Type",
  filter_type_help: "Type of filter",
  filter: "Filter",
  filter_help: "Folders/Tags to filter on, split by ,",
  only_favorites: "Show only favorites",
  show_read: "Show read",
  show_unread: "Show unread",
  filter_folder_help: "Only show articles from the following folders",
  filter_feed_help: "Only show articles from the following feeds",
  filter_tags_help: "Only show articles with the following tags",
  from_folders: "from folders: ",
  from_feeds: "from feeds: ",
  with_tags: "with tags: ",
  no_feed_with_name: "There is no feed with this name",
  invalid_tag: "This is not a valid tag",
  note_exists: "there is already a note with that name",
  invalid_filename: "that filename is not valid",
  specify_name: "Please specify a filename",
  cannot_contain: "cannot contain:",
  created_note: "Created note from article",
  inserted_article: "inserted article into note",
  no_file_active: "no file active",
  settings: "Settings",
  file_creation: "File creation",
  template_new: "new file template",
  template_new_help: "When creating a note from a article this gets processed.",
  template_paste: "paste article template",
  template_paste_help: "When pasting/copying an article this gets processed.",
  available_variables: "Available variables are:",
  file_location: "Default location for new notes",
  file_location_help: "Where newly created notes are placed",
  file_location_default: "In the default folder",
  file_location_custom: "In the folder specified below",
  file_location_folder: "Folder to create new articles in",
  file_location_folder_help: "newly created articles will appear in this folder",
  date_format: "Date format",
  syntax_reference: "Syntax Reference",
  syntax_looks: "Your current syntax looks like this: ",
  ask_filename: "Ask for filename",
  ask_filename_help: "Disable to apply the template below automatically(with invalid symbols removed)",
  refresh_time: "Refresh time",
  refresh_time_help: "How often should the feeds be refreshed, in minutes, use 0 to disable",
  specify_positive_number: "please specify a positive number",
  multi_device_usage: "Multi device usage",
  multi_device_usage_help: "Keep article status synced when using multiple devices at the same time\n(Requires a restart to become effective)",
  add_new_filter: "Add new filtered folder",
  filter_exists: "you already have a filter configured with that name",
  hotkeys: "Hotkeys",
  hotkeys_reading: "when reading a article",
  press_key: "press a key",
  customize_hotkey: "customize this hotkey",
  refreshed_feeds: "Feeds refreshed",
  import: "Import",
  import_opml: "Import from OPML",
  imported_x_feeds: "Imported %1 feeds",
  choose_file: "Choose file",
  choose_file_help: "Choose file to import",
  export_opml: "Export as OPML",
  default_filename: "Template for filename",
  default_filename_help: "All variables from the paste template are available",
  cleanup: "Cleanup articles",
  cleanup_help: "Removes entries which fit the criteria specified below.",
  cleanup_help2: "Keep in mind that articles that still exist in the feed will reappear on the next refresh",
  perform_cleanup: "Perform cleanup",
  all: "all",
  from_feed: "from feed",
  older_than: "older than X Days",
  older_than_help: "keep empty for all, will be ignored if there is no publishing date associated with entry",
  advanced: "Advanced",
  remove_wrong_feed: "Remove all articles that are in the incorrect feed",
  remove_wrong_feed_help: "This might have happened due to a bug in versions pre 0.8",
  scanning_items: "Scanning Articles (%1 / %2)",
  created_export: "Created OPML file in your Vaults root folder",
  add: "Add",
  from_archive: "Get old articles from archive.org",
  reading_archive: "Reading data from archive",
  scanning_duplicates: "Scanning for duplicates",
  do_not_close: "Please do not close this window",
  display_style: "Display Style",
  list: "List",
  cards: "Cards",
  customize_terms: "Customize Terms",
  content: "Content",
  highlight: "Highlight",
  highlight_remove: "remove highlight",
  filter_folder_ignore_help: "ignore the following folders",
  filter_feed_ignore_help: "ignore the following feeds",
  filter_tags_ignore_help: "ignore the following tags",
  loading: "Loading",
  article_title: "Title",
  article_link: "Link to article",
  article_author: "Author of article",
  article_published: "Date published",
  article_description: "Short article description",
  article_content: "article content",
  article_tags: "Tags split by comma",
  article_media: "Link to video/audio file",
  feed_folder: "Folder of feed",
  feed_title: "Title of feed",
  highlights: "Highlights",
  note_created: "Note creation date",
  filename: "Filename",
  display_media: "Include Media",
  base_folder: "Base folder"
};

// src/l10n/locales/de.ts
var de_default = {
  RSS_Reader: "RSS Reader",
  RSS_Feeds: "RSS Feeds",
  open: "\xD6ffnen",
  refresh_feeds: "Feeds neu laden",
  create_all: "Alle erstellen",
  mark_all_as_read: "Alle als gelesen markieren",
  add_tags_to_all: "Tags zu allen hinzuf\xFCgen",
  filtered_folders: "Gefilterte Ordner",
  folders: "Ordner",
  folder: "Ordner",
  feeds: "Feeds",
  create_note: "Neue Notiz erstellen",
  paste_to_note: "In aktuelle Notiz einf\xFCgen",
  copy_to_clipboard: "In die Zwischenablage kopieren",
  open_browser: "Im Webbrowser \xF6ffnen",
  edit_tags: "Tags bearbeiten",
  mark_as_read: "Als gelesen markieren",
  mark_as_unread: "Als ungelesen markieren",
  mark_as_favorite: "As Favorit markieren",
  remove_from_favorites: "Aus den Favoriten entfernen",
  read_article_tts: "Vorlesen",
  next: "n\xE4chster",
  previous: "vorheriger",
  mark_as_read_unread: "Als gelesen/ungelesen markieren",
  mark_as_favorite_remove: "Als Favorit markieren/Aus den Favoriten entfernen",
  marked_as_read: "Als gelesen markiert",
  marked_as_unread: "Als ungelesen markiert",
  removed_from_favorites: "Von den Favoriten entfernt",
  added_to_favorites: "Als Favorit markiert",
  read: "gelesen",
  unread: "ungelesen",
  favorites: "Favoriten",
  favorite: "Favorit",
  tags: "Tags",
  tag: "Tag",
  save: "Speichern",
  cancel: "Abbrechen",
  delete: "L\xF6schen",
  edit: "Bearbeiten",
  reset: "zur\xFCcksetzen",
  fix_errors: "Bitte behebe die Fehler vor dem speichern.",
  add_new: "neu hinzuf\xFCgen",
  add_new_feed: "neuen Feed hinzuf\xFCgen",
  feed_already_configured: "Es existiert bereits ein Feed mit dieser URL",
  no_folder: "Kein Ordner",
  name: "Name",
  name_help: "Unter welchem Namen soll dieser Feed angezeigt werden?",
  url_help: "Wie lautet die URL zu diesem Feed?",
  folder_help: "Als was kategorisierst du diesen Feed?",
  invalid_name: "Du must einen g\xFCltigen Namen vergeben",
  invalid_url: "diese URL ist nicht g\xFCltig",
  invalid_feed: "Dieser Feed hat keine Eintr\xE4ge",
  filter_tags: "Alle Artikel mit Tags",
  filter_unread: "Alle ungelesenen Artikel(aus Ordnern)",
  filter_read: "Alle gelesenen Artikel(aus Ordnern)",
  filter_favorites: "Favoriten(aus Ordnern)",
  sort_date_newest: "Ver\xF6ffentlichungsdatum (neu - alt)",
  sort_date_oldest: "Ver\xF6ffentlichungsdatum (alt - neu)",
  sort_alphabet_normal: "Name (A - Z)",
  sort_alphabet_inverted: "Name (Z - A)",
  sort: "Ordnen nach",
  filter_name_help: "Wie soll der Filter angezeigt werden?",
  filter_type: "Typ",
  filter_type_help: "Typ des Filters",
  filter: "Filter",
  filter_help: "Order/Tags die gefiltert werden sollen, getrennt durch ,",
  only_favorites: "Zeige nur Favoriten",
  show_read: "Zeige gelesene",
  show_unread: "Zeige ungelesene",
  filter_folder_help: "Zeige nur Artikel aus den folgenden Ordnern",
  filter_feed_help: "Zeige nur Artikel aus den folgenden Feeds",
  filter_tags_help: "Zeige nur Artikel mit den folgenden Tags",
  from_folders: "Aus Ordnern: ",
  from_feeds: "Aus Feeds: ",
  with_tags: "Mit Tags: ",
  no_feed_with_name: "Es existiert kein Feed mit diesem Namen",
  invalid_tag: "Dieser Tag ist nicht g\xFCltig",
  note_exists: "Es existiert bereits eine Notiz mit diesem Namen",
  invalid_filename: "Der Dateiname ist nicht g\xFCltig",
  specify_name: "Bitte einen Dateinamen angeben",
  cannot_contain: "kann nicht enhalten:",
  created_note: "Notiz erstellt",
  inserted_article: "in Notiz eingef\xFCgt",
  no_file_active: "Keine Datei ge\xF6ffnet",
  settings: "Einstellungen",
  file_creation: "Dateierstellung",
  template_new: "Vorlage f\xFCr neue Dateien",
  template_new_help: "Beim erstellen einer Notiz wird dies verarbeitet.",
  template_paste: "Vorlage beim Einf\xFCgen in eine Datei",
  template_paste_help: "Beim einf\xFCgen/in die Zwischenablage kopieren wird dies verarbeitet.",
  available_variables: "M\xF6gliche Variablen sind:",
  file_location: "Speicherort f\xFCr neue Notizen",
  file_location_help: "Wo sollen neue Notizen gespeichert werden?",
  file_location_default: "In Standardordner",
  file_location_custom: "Eigenen Ordner festlegen",
  file_location_folder: "Ordner f\xFCr neue Notizen",
  file_location_folder_help: "Speichert neue Notizen an diesem Ort",
  date_format: "Datumsformat",
  syntax_reference: "Syntax Referenz",
  syntax_looks: "So wird es aussehen: ",
  ask_filename: "Nach Dateiname fragen",
  ask_filename_help: "Deaktivieren um die Vorlage automatisch anzuwenden(ohne ung\xFCltige Zeichen)",
  refresh_time: "Aktualisierungsintervall",
  refresh_time_help: "Wie h\xE4ufig soll auf neue Eintr\xE4ge \xFCberpr\xFCft werden(in Minuten), 0 zu deaktivieren",
  specify_positive_number: "Bitte eine positive Zahl angeben",
  multi_device_usage: "Mit mehreren Ger\xE4ten nutzen",
  multi_device_usage_help: "Syncronisiere Lesestatus & Tags zwischen mehreren gleichzeitig genutzten Ger\xE4ten\n(Ben\xF6tigt einen Neustart der App)",
  add_new_filter: "Neuen gefilterten Ordner erstellen",
  filter_exists: "Es exisitiert bereits ein Feed mit diesem Namen",
  hotkeys: "Tastenk\xFCrzel",
  hotkeys_reading: "in der Leseansicht",
  press_key: "dr\xFCcke eine Taste",
  customize_hotkey: "dieses Tastenk\xFCrzel anpassen",
  refreshed_feeds: "Feeds aktualisiert",
  import: "Importieren",
  import_opml: "Aus OPML importieren",
  imported_x_feeds: "%1 Feeds importiert",
  choose_file: "Datei ausw\xE4hlen",
  choose_file_help: "W\xE4hle eine Datei aus der importiert werden soll",
  export_opml: "Als OPML exportieren",
  default_filename: "Vorlage f\xFCr Dateinamen",
  default_filename_help: "Alle Variablen aus der einf\xFCgen Vorlage k\xF6nnen verwendet werden",
  cleanup: "Artikel aufr\xE4umen",
  cleanup_help: "Entfernt alle Artikel auf die folgende Kriterien zutreffen",
  cleanup_help2: "Alle Artikel die noch im Feed vorhanden sind werden beim n\xE4chsten aktualisieren wieder erscheinen",
  perform_cleanup: "ausf\xFChren",
  all: "Alle",
  from_feed: "von Feed",
  older_than: "\xE4lter als X Tage",
  older_than_help: "Leerlassen f\xFCr alle, wird ignoriert wenn Artikel kein Ver\xF6ffentlichungsdatum hat",
  advanced: "Erweitert",
  remove_wrong_feed: "Alle Artikel entfernen die im falschen Feed gelandet sind",
  remove_wrong_feed_help: "Aufgrund eines Fehlers in Versionen vor 0.8 k\xF6nnte dies passiert sein",
  scanning_items: "Verarbeite Artikel (%1 / %2)",
  created_export: "OPML Export in Vault erstellt",
  add: "Hinzuf\xFCgen",
  from_archive: "Alte Artikel von archive.org lesen",
  reading_archive: "Daten werden aus Archiv geladen",
  scanning_duplicates: "Entferne Duplikate",
  do_not_close: "Bitte dieses Fenster nicht schliesen",
  display_style: "Anzeige",
  list: "List",
  cards: "Karten",
  customize_terms: "Begriffe anpassen",
  content: "Inhalt",
  highlight: "Markieren",
  highlight_remove: "Markierung entfernen",
  filter_folder_ignore_help: "diese Ordner ignorieren",
  filter_feed_ignore_help: "diese Feeds ignorieren",
  filter_tags_ignore_help: "diese Tags ignorieren",
  loading: "L\xE4dt",
  article_title: "Titel",
  article_link: "Link zum Artikel",
  article_author: "Autor",
  article_published: "Ver\xF6ffentlichungsdatum",
  article_description: "Kurze Beschreibung des Artikels",
  article_content: "Inhalt des Artikels",
  article_tags: "Tags getrennt durch Komma",
  article_media: "Link zu Video/Audio Datei",
  feed_folder: "Ordner des Feeds",
  feed_title: "Feed Titel",
  highlights: "Highlights",
  note_created: "Erstelldatum der Notiz",
  filename: "Dateiname"
};

// src/l10n/locales/zh.ts
var zh_default = {
  RSS_Reader: "RSS Reader",
  RSS_Feeds: "\u8BA2\u9605\u6E90",
  open: "\u6253\u5F00",
  refresh_feeds: "\u66F4\u65B0\u8BA2\u9605",
  create_all: "\u521B\u5EFA\u5168\u90E8",
  mark_all_as_read: "\u5168\u90E8\u6807\u8BB0\u4E3A\u5DF2\u8BFB",
  add_tags_to_all: "\u4E3A\u6240\u6709\u6761\u76EE\u6DFB\u52A0\u6807\u7B7E",
  filtered_folders: "\u7B5B\u9009\u5206\u7C7B",
  folders: "\u5206\u7C7B",
  folder: "\u5206\u7C7B",
  feeds: "\u8BA2\u9605\u6E90",
  create_note: "\u65B0\u5EFA\u7B14\u8BB0",
  paste_to_note: "\u7C98\u8D34\u5230\u5F53\u524D\u7B14\u8BB0",
  copy_to_clipboard: "\u590D\u5236\u5230\u526A\u5207\u677F",
  open_browser: "\u7528\u6D4F\u89C8\u5668\u6253\u5F00",
  edit_tags: "\u7F16\u8F91\u6807\u7B7E",
  mark_as_read: "\u6807\u8BB0\u4E3A\u5DF2\u8BFB",
  mark_as_unread: "\u6807\u8BB0\u4E3A\u672A\u8BFB",
  mark_as_favorite: "\u6DFB\u52A0\u5230\u6536\u85CF\u5939",
  remove_from_favorites: "\u4ECE\u6536\u85CF\u5939\u4E2D\u5220\u9664",
  read_article_tts: "\u8BED\u97F3(TTS)\u9605\u8BFB\u6587\u7AE0",
  next: "\u4E0B\u4E00\u7BC7",
  previous: "\u4E0A\u4E00\u7BC7",
  mark_as_read_unread: "\u6807\u8BB0\u4E3A\u5DF2\u8BFB/\u672A\u8BFB",
  mark_as_favorite_remove: "\u6DFB\u52A0\u5230\u6536\u85CF\u5939/\u4ECE\u6536\u85CF\u5939\u4E2D\u5220\u9664",
  marked_as_read: "\u5DF2\u6807\u8BB0\u4E3A\u5DF2\u8BFB",
  marked_as_unread: "\u5DF2\u6807\u8BB0\u4E3A\u672A\u8BFB",
  removed_from_favorites: "\u5DF2\u4ECE\u6536\u85CF\u5939\u4E2D\u5220\u9664",
  added_to_favorites: "\u5DF2\u6DFB\u52A0\u5230\u6536\u85CF\u5939",
  read: "\u5DF2\u8BFB",
  unread: "\u672A\u8BFB",
  favorites: "\u6536\u85CF\u5939",
  favorite: "\u6536\u85CF",
  tags: "\u6807\u7B7E",
  tag: "\u6807\u7B7E",
  save: "\u4FDD\u5B58",
  cancel: "\u53D6\u6D88",
  delete: "\u5220\u9664",
  edit: "\u7F16\u8F91",
  reset: "\u6062\u590D\u9ED8\u8BA4\u503C",
  fix_errors: "\u8BF7\u5728\u4FDD\u5B58\u524D\u4FEE\u590D\u9519\u8BEF\u3002",
  add_new: "\u6DFB\u52A0",
  add_new_feed: "\u6DFB\u52A0\u65B0\u8BA2\u9605\u6E90",
  feed_already_configured: "\u60A8\u5DF2\u7ECF\u6DFB\u52A0\u4E86\u8BE5 URL \u5730\u5740\u7684\u8BA2\u9605\u6E90",
  no_folder: "\u672A\u5206\u7C7B",
  name: "\u540D\u79F0",
  name_help: "\u8BBE\u7F6E\u8BA2\u9605\u6E90\u540D\u79F0",
  url_help: "\u8F93\u5165\u8BA2\u9605\u6E90\u7684 URL \u5730\u5740",
  folder_help: "\u8BBE\u7F6E\u8BA2\u9605\u6E90\u5206\u7C7B",
  invalid_name: "\u8BF7\u8F93\u5165\u8BA2\u9605\u6E90\u540D\u79F0",
  invalid_url: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u8BA2\u9605\u6E90 URL \u5730\u5740",
  invalid_feed: "\u6B64\u8BA2\u9605\u6E90\u6CA1\u6709\u4EFB\u4F55\u5185\u5BB9",
  filter_tags: "\u5DF2\u6253\u6807\u7B7E\u7684\u6587\u7AE0",
  filter_unread: "\u5168\u90E8\u672A\u8BFB\u6587\u7AE0(\u6765\u81EA\u5206\u7C7B)",
  filter_read: "\u5168\u90E8\u5DF2\u8BFB\u6587\u7AE0(\u6765\u81EA\u5206\u7C7B)",
  filter_favorites: "\u6536\u85CF\u5939(\u6765\u81EA\u5206\u7C7B)",
  sort_date_newest: "\u53D1\u5E03\u65E5\u671F (\u65B0 \u2192 \u65E7)",
  sort_date_oldest: "\u53D1\u5E03\u65E5\u671F (\u65E7 to \u65B0)",
  sort_alphabet_normal: "\u540D\u79F0 (A \u2192 Z)",
  sort_alphabet_inverted: "\u540D\u79F0 (Z \u2192 A)",
  sort: "\u6392\u5E8F",
  filter_name_help: "\u8BBE\u7F6E\u7B5B\u9009\u5668\u540D\u79F0",
  filter_type: "\u7C7B\u578B",
  filter_type_help: "\u7B5B\u9009\u5668\u7C7B\u578B",
  filter: "\u7B5B\u9009\u5668",
  filter_help: "\u8981\u7B5B\u9009\u7684\u5206\u7C7B/\u6807\u7B7E,",
  only_favorites: "\u4EC5\u663E\u793A\u5DF2\u6536\u85CF",
  show_read: "\u663E\u793A\u5DF2\u8BFB",
  show_unread: "\u663E\u793A\u672A\u8BFB",
  filter_folder_help: "\u4EC5\u663E\u793A\u4EE5\u4E0B\u5206\u7C7B\u4E2D\u7684\u6587\u7AE0",
  filter_feed_help: "\u4EC5\u663E\u793A\u4EE5\u4E0B\u8BA2\u9605\u6E90\u4E2D\u7684\u6587\u7AE0",
  filter_tags_help: "\u4EC5\u663E\u793A\u4EE5\u4E0B\u6807\u7B7E\u4E2D\u7684\u6587\u7AE0",
  from_folders: "\u6765\u81EA\u5206\u7C7B: ",
  from_feeds: "\u6765\u81EA\u8BA2\u9605\u6E90: ",
  with_tags: "\u6765\u81EA\u6807\u7B7E: ",
  invalid_tag: "\u6B64\u6807\u7B7E\u65E0\u6548",
  note_exists: "\u5DF2\u5B58\u5728\u540C\u540D\u7B14\u8BB0",
  invalid_filename: "\u6587\u4EF6\u540D\u65E0\u6548",
  specify_name: "\u8BF7\u8F93\u5165\u6587\u4EF6\u540D",
  cannot_contain: "\u4E0D\u80FD\u5305\u542B: ",
  created_note: "\u5DF2\u5C06\u8BE5\u6587\u7AE0\u590D\u5236\u4E3A\u7B14\u8BB0",
  inserted_article: "\u5DF2\u5C06\u8BE5\u6587\u7AE0\u590D\u5236\u5230\u5F53\u524D\u7B14\u8BB0",
  no_file_active: "\u6CA1\u6709\u6587\u4EF6\u5904\u4E8E\u6D3B\u52A8\u72B6\u6001",
  settings: "\u8BBE\u7F6E",
  file_creation: "\u65B0\u5EFA\u7B14\u8BB0",
  template_new: "\u7B14\u8BB0\u6A21\u677F",
  template_new_help: "\u4F7F\u7528\u8BA2\u9605\u6587\u7AE0\u521B\u5EFA\u7B14\u8BB0\u65F6\uFF0C\u4F1A\u6839\u636E\u5DF2\u8BBE\u7F6E\u7684\u6A21\u677F\u53D8\u91CF\u8FDB\u884C\u5904\u7406\u3002",
  template_paste: "\u590D\u5236/\u7C98\u8D34\u6A21\u677F",
  template_paste_help: "\u5C06\u8BA2\u9605\u6587\u7AE0\u590D\u5236/\u7C98\u8D34\u4E3A\u7B14\u8BB0\u65F6\uFF0C\u4F1A\u6839\u636E\u5DF2\u8BBE\u7F6E\u7684\u6A21\u677F\u53D8\u91CF\u8FDB\u884C\u5904\u7406\u3002",
  available_variables: "\u53EF\u7528\u6A21\u677F\u53D8\u91CF: ",
  file_location: "\u4FDD\u5B58\u4F4D\u7F6E",
  file_location_help: "\u8BF7\u9009\u62E9\u8981\u4FDD\u5B58\u65B0\u5EFA\u7B14\u8BB0\u7684\u4F4D\u7F6E",
  file_location_default: "\u9ED8\u8BA4\u76EE\u5F55",
  file_location_custom: "\u81EA\u5B9A\u4E49\u76EE\u5F55",
  file_location_folder: "\u8BF7\u9009\u62E9\u8981\u4FDD\u5B58\u65B0\u5EFA\u7B14\u8BB0\u7684\u76EE\u5F55",
  file_location_folder_help: "\u65B0\u521B\u5EFA\u7684\u7B14\u8BB0\u5C06\u4FDD\u5B58\u5728\u8BE5\u76EE\u5F55\u4E2D",
  date_format: "\u65E5\u671F\u683C\u5F0F",
  syntax_reference: "\u65E5\u671F\u683C\u5F0F\u8BED\u6CD5\u53C2\u8003",
  syntax_looks: "\u5F53\u524D\u65E5\u671F\u683C\u5F0F: ",
  ask_filename: "\u786E\u8BA4\u6587\u4EF6\u540D",
  ask_filename_help: "\u7981\u7528\u5219\u81EA\u52A8\u4F7F\u7528\u4E0B\u9762\u7684\u6587\u4EF6\u540D\u6A21\u677F\u521B\u5EFA\u6587\u4EF6\uFF08\u81EA\u52A8\u5220\u9664\u65E0\u6548\u7684\u6587\u4EF6\u540D\u5B57\u7B26\uFF09",
  refresh_time: "\u66F4\u65B0\u9891\u7387",
  refresh_time_help: "\u591A\u4E45\u66F4\u65B0\u4E00\u6B21\u8BA2\u9605\u6E90\uFF08\u5355\u4F4D: \u5206\u949F\uFF09\uFF0C\u8BBE\u7F6E\u4E3A0\u5219\u7981\u7528\u3002",
  specify_positive_number: "\u8BF7\u8F93\u5165\u6B63\u6570",
  multi_device_usage: "\u591A\u8BBE\u5907\u4F7F\u7528",
  multi_device_usage_help: "\u540C\u65F6\u4F7F\u7528\u591A\u4E2A\u8BBE\u5907\u65F6\u4FDD\u6301\u6587\u7AE0\u72B6\u6001\u540C\u6B65\n(\u9700\u8981\u91CD\u65B0\u542F\u52A8\u624D\u80FD\u751F\u6548)",
  add_new_filter: "\u6DFB\u52A0\u65B0\u7B5B\u9009\u5668",
  filter_exists: "\u5DF2\u5B58\u5728\u540C\u540D\u7B5B\u9009\u5668",
  hotkeys: "\u5FEB\u6377\u952E",
  hotkeys_reading: "\u9605\u8BFB\u6587\u7AE0\u65F6",
  press_key: "\u6309\u4E0B\u5FEB\u6377\u952E",
  customize_hotkey: "\u5206\u914D\u5FEB\u6377\u952E",
  refreshed_feeds: "\u5DF2\u66F4\u65B0 RSS \u8BA2\u9605\u6E90",
  import: "\u5BFC\u5165",
  import_opml: "\u901A\u8FC7 OPML \u5BFC\u5165",
  imported_x_feeds: "\u5DF2\u5BFC\u5165 %1 \u6761\u8BA2\u9605\u6E90",
  choose_file: "\u9009\u62E9\u6587\u4EF6",
  choose_file_help: "\u8BF7\u9009\u62E9\u8981\u5BFC\u5165\u7684\u6587\u4EF6",
  export_opml: "\u5BFC\u51FA OPML \u6587\u4EF6",
  default_filename: "\u6587\u4EF6\u540D\u6A21\u677F",
  default_filename_help: "\u4E0A\u9762\u521B\u5EFA\u7B14\u8BB0\u7684\u6240\u6709\u6A21\u677F\u53D8\u91CF\u90FD\u53EF\u7528",
  cleanup: "\u6E05\u9664\u6587\u7AE0",
  cleanup_help: "\u6E05\u9664\u7B26\u5408\u4EE5\u4E0B\u89C4\u5219\u7684\u6587\u7AE0",
  cleanup_help2: "\u6CE8\u610F\uFF0C\u8BA2\u9605\u6E90\u4E2D\u4ECD\u5B58\u5728\u7684\u6587\u7AE0\u5C06\u5728\u4E0B\u6B21\u5237\u65B0\u65F6\u91CD\u65B0\u51FA\u73B0",
  perform_cleanup: "\u6E05\u9664\u6587\u7AE0",
  all: "\u5168\u90E8",
  from_feed: "\u6765\u81EA\u8BA2\u9605\u6E90",
  older_than: "\u591A\u5C11\u5929\u4E4B\u524D\u53D1\u5E03\u7684\u6587\u7AE0",
  older_than_help: "\u5982\u679C\u6CA1\u6709\u7B26\u5408\u7684\u6587\u7AE0\uFF0C\u5219\u5FFD\u7565\u8BE5\u6761\u89C4\u5219\uFF08\u4E3A\u7A7A\u5219\u4FDD\u7559\u6240\u6709\u65E5\u671F\u7684\u6587\u7AE0\uFF09",
  advanced: "\u9AD8\u7EA7\u8BBE\u7F6E",
  remove_wrong_feed: "\u6E05\u9664\u6240\u6709\u4E0D\u6B63\u786E\u8BA2\u9605\u6E90\u4E2D\u7684\u6587\u7AE0",
  remove_wrong_feed_help: "\u8FD9\u53EF\u80FD\u662F\u7531\u4E8E0.8\u4E4B\u524D\u7248\u672C\u4E2D\u7684\u9519\u8BEF\u9020\u6210\u7684",
  scanning_items: "\u626B\u63CF\u6587\u7AE0 (%1 / %2))",
  created_export: "\u5DF2\u5728\u7B14\u8BB0\u4ED3\u5E93\u6839\u76EE\u5F55\u521B\u5EFA OPML \u6587\u4EF6",
  add: "\u6DFB\u52A0",
  from_archive: "\u4ECE\u4E92\u8054\u7F51\u6863\u6848\u9986(archive.org)\u83B7\u53D6\u65E7\u6587\u7AE0",
  reading_archive: "\u6B63\u5728\u4ECE\u5B58\u6863\u4E2D\u8BFB\u53D6\u6570\u636E",
  scanning_duplicates: "\u626B\u63CF\u91CD\u590D\u6587\u7AE0",
  do_not_close: "\u8BF7\u52FF\u5173\u95ED\u6B64\u7A97\u53E3",
  display_style: "\u663E\u793A\u98CE\u683C",
  list: "\u5217\u8868",
  cards: "\u5361\u7247",
  customize_terms: "\u81EA\u5B9A\u4E49\u672F\u8BED",
  content: "\u5185\u5BB9\u8BBE\u7F6E",
  highlight: "\u9AD8\u4EAE",
  highlight_remove: "\u5220\u9664\u9AD8\u4EAE",
  filter_folder_ignore_help: "\u5FFD\u7565\u4EE5\u4E0B\u5206\u7C7B",
  filter_feed_ignore_help: "\u5FFD\u7565\u4EE5\u4E0B\u8BA2\u9605\u6E90",
  filter_tags_ignore_help: "\u5FFD\u7565\u4EE5\u4E0B\u6807\u7B7E",
  loading: "\u6B63\u5728\u52A0\u8F7D"
};

// src/l10n/locales/test.ts
var test_default = {
  "testingValue": "Hello World",
  testingInserts: "Hello %1 %2"
};

// src/l10n/locale.ts
var locale = window.moment ? window.moment.locale() : "test";
var localeMap = {
  en: en_default,
  de: de_default,
  "zh-cn": zh_default,
  test: test_default
};
var userLocale = localeMap[locale];
function t(str, ...inserts) {
  var _a;
  let localeStr = (_a = userLocale && userLocale[str]) != null ? _a : en_default[str];
  for (let i = 0; i < inserts.length; i++) {
    localeStr = localeStr.replace(`%${i + 1}`, inserts[i]);
  }
  return localeStr;
}

// src/modals/TextInputPrompt.ts
var TextInputPrompt = class extends BaseModal {
  constructor(app, promptText, hint, defaultValue, placeholder, buttonText = t("save")) {
    super(app);
    this.promptText = promptText;
    this.hint = hint;
    this.defaultValue = defaultValue;
    this.placeholder = placeholder;
    this.buttonText = buttonText;
  }
  onOpen() {
    this.titleEl.setText(this.promptText);
    this.createForm();
  }
  onClose() {
    this.contentEl.empty();
  }
  createForm() {
    const div = this.contentEl.createDiv();
    const text2 = new import_obsidian4.Setting(div).setName(this.promptText).setDesc(this.hint).addText((textComponent) => {
      textComponent.setValue(this.defaultValue).setPlaceholder(this.placeholder).onChange(() => {
        this.removeValidationError(textComponent);
      }).inputEl.setAttribute("size", "50");
      this.textComponent = textComponent;
    });
    text2.controlEl.addClass("rss-setting-input");
    new import_obsidian4.Setting(div).addButton((b) => {
      b.setButtonText(this.buttonText).onClick(() => __async(this, null, function* () {
        this.resolve(this.textComponent);
      }));
      return b;
    });
  }
  openAndGetValue(resolve) {
    return __async(this, null, function* () {
      this.resolve = resolve;
      yield this.open();
    });
  }
};

// node_modules/obsidian-community-lib/dist/utils.js
var feather = __toModule(require_feather());
var import_obsidian5 = __toModule(require("obsidian"));
function copy(content, success = () => new import_obsidian5.Notice("Copied to clipboard"), failure = (reason) => {
  new import_obsidian5.Notice("Could not copy to clipboard");
  console.log({ reason });
}) {
  return __async(this, null, function* () {
    yield navigator.clipboard.writeText(content).then(success, failure);
  });
}
var isInVault = (app, noteName, sourcePath = "") => !!app.metadataCache.getFirstLinkpathDest(noteName, sourcePath);

// src/functions.ts
function createNewNote(plugin, item) {
  return __async(this, null, function* () {
    const activeFile = plugin.app.workspace.getActiveFile();
    let dir = plugin.app.fileManager.getNewFileParent(activeFile ? activeFile.path : "").path;
    if (plugin.settings.saveLocation === "custom") {
      dir = plugin.settings.saveLocationFolder;
    }
    let filename = applyTemplate(plugin, item, plugin.settings.defaultFilename);
    filename = filename.replace(/[\/\\:]/g, " ");
    if (plugin.settings.askForFilename) {
      const inputPrompt = new TextInputPrompt(plugin.app, t("specify_name"), t("cannot_contain") + ' * " \\ / < > : | ?', filename, filename);
      yield inputPrompt.openAndGetValue((text2) => __async(this, null, function* () {
        const value = text2.getValue();
        if (value.match(FILE_NAME_REGEX)) {
          inputPrompt.setValidationError(text2, t("invalid_filename"));
          return;
        }
        const filePath = (0, import_obsidian6.normalizePath)([dir, `${value}.md`].join("/"));
        if (isInVault(plugin.app, filePath, "")) {
          inputPrompt.setValidationError(text2, t("note_exists"));
          return;
        }
        inputPrompt.close();
        yield createNewFile(plugin, item, filePath, value);
      }));
    } else {
      const replacedTitle = filename.replace(FILE_NAME_REGEX, "");
      const filePath = (0, import_obsidian6.normalizePath)([dir, `${replacedTitle}.md`].join("/"));
      yield createNewFile(plugin, item, filePath, item.title);
    }
  });
}
function createNewFile(plugin, item, path, title) {
  return __async(this, null, function* () {
    if (isInVault(plugin.app, path, "")) {
      new import_obsidian6.Notice(t("note_exists"));
      return;
    }
    const appliedTemplate = applyTemplate(plugin, item, plugin.settings.template, title);
    const file = yield plugin.app.vault.create(path, appliedTemplate);
    yield plugin.app.workspace.activeLeaf.openFile(file, {
      state: { mode: "edit" }
    });
    item.created = true;
    const items = plugin.settings.items;
    yield plugin.writeFeedContent(() => {
      return items;
    });
    new import_obsidian6.Notice(t("created_note"));
  });
}
function pasteToNote(plugin, item) {
  return __async(this, null, function* () {
    const file = plugin.app.workspace.getActiveFile();
    if (file === null) {
      new import_obsidian6.Notice(t("no_file_active"));
      return;
    }
    const view = plugin.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
    if (view) {
      const appliedTemplate = applyTemplate(plugin, item, plugin.settings.pasteTemplate);
      const editor = view.editor;
      editor.replaceRange(appliedTemplate, editor.getCursor());
      item.created = true;
      const items = plugin.settings.items;
      yield plugin.writeFeedContent(() => {
        return items;
      });
      new import_obsidian6.Notice(t("RSS_Reader") + t("inserted_article"));
    }
  });
}
function applyTemplate(plugin, item, template, filename) {
  let result = template.replace(/{{title}}/g, item.title);
  result = result.replace(/{{link}}/g, item.link);
  result = result.replace(/{{author}}/g, item.creator);
  result = result.replace(/{{published}}/g, (0, import_obsidian6.moment)(item.pubDate).format(plugin.settings.dateFormat));
  result = result.replace(/{{created}}/g, (0, import_obsidian6.moment)().format(plugin.settings.dateFormat));
  result = result.replace(/{{date}}/g, (0, import_obsidian6.moment)().format(plugin.settings.dateFormat));
  result = result.replace(/{{feed}}/g, item.feed);
  result = result.replace(/{{folder}}/g, item.folder);
  result = result.replace(/{{description}}/g, item.description);
  result = result.replace(/{{media}}/g, item.enclosure);
  result = result.replace(/({{published:).*(}})/g, function(k) {
    const value = k.split(":")[1];
    const format2 = value.substring(0, value.indexOf("}"));
    return (0, import_obsidian6.moment)(item.pubDate).format(format2);
  });
  result = result.replace(/({{created:).*(}})/g, function(k) {
    const value = k.split(":")[1];
    const format2 = value.substring(0, value.indexOf("}"));
    return (0, import_obsidian6.moment)().format(format2);
  });
  result = result.replace(/({{tags:).*(}})/g, function(k) {
    const value = k.split(":")[1];
    const separator = value.substring(0, value.indexOf("}"));
    return item.tags.join(separator);
  });
  result = result.replace(/({{#tags:).*(}})/g, function(k) {
    const value = k.split(":")[1];
    const separator = value.substring(0, value.indexOf("}"));
    return item.tags.map((i) => "#" + i).join(separator);
  });
  result = result.replace(/{{tags}}/g, item.tags.join(", "));
  result = result.replace(/{{#tags}}/g, item.tags.map((i) => "#" + i).join(", "));
  result = result.replace(/{{highlights}}/g, item.highlights.map((value) => {
    return "- " + rssToMd(plugin, removeFormatting(value).replace(/^(-+)/, ""));
  }).join("\n"));
  result = result.replace(/({{highlights:)[\s\S][^}]*(}})/g, function(k) {
    const value = k.split(/(:[\s\S]?)/);
    const tmp = value.slice(1).join("");
    const template2 = tmp.substring(1, tmp.indexOf("}"));
    return item.highlights.map((i) => {
      return template2.replace(/%%highlight%%/g, rssToMd(plugin, removeFormatting(i)).replace(/^(-+)/, ""));
    }).join("");
  });
  if (filename) {
    result = result.replace(/{{filename}}/g, filename);
  }
  let content = rssToMd(plugin, item.content);
  item.highlights.forEach((highlight) => {
    const mdHighlight = (0, import_obsidian6.htmlToMarkdown)(highlight);
    content = content.replace(mdHighlight, "==" + mdHighlight + "==");
  });
  content = content.replace(/\$/g, "$$$");
  result = result.replace(/{{content}}/g, content);
  return result;
}
function removeFormatting(html) {
  const doc = new DOMParser().parseFromString(html, "text/html");
  const elements = doc.querySelectorAll("html body a");
  for (let i = 0; i < elements.length; i++) {
    const el = elements.item(i);
    if (el.dataset) {
      Object.keys(el.dataset).forEach((key) => {
        delete el.dataset[key];
      });
    }
  }
  const objects = doc.querySelectorAll("object");
  for (let i = 0; i < objects.length; i++) {
    const object = objects.item(i);
    object.remove();
  }
  return doc.documentElement.innerHTML;
}
function openInBrowser(item) {
  if (typeof item.link === "string") {
    window.open(item.link, "_blank");
  }
}
function rssToMd(plugin, content) {
  let markdown = (0, import_obsidian6.htmlToMarkdown)(content);
  if (plugin.app.plugins.plugins["dataview"]) {
    const {
      inlineQueryPrefix,
      inlineJsQueryPrefix
    } = plugin.app.plugins.plugins.dataview.api.settings;
    markdown = markdown.replace(RegExp(`\`${escapeRegExp(inlineQueryPrefix)}.*\``, "g"), "<pre>$&</pre>");
    markdown = markdown.replace(RegExp(`\`${escapeRegExp(inlineJsQueryPrefix)}.*\``, "g"), "<pre>$&</pre>");
  }
  if (plugin.app.plugins.plugins["templater-obsidian"]) {
    markdown = markdown.replace(/<%([\s\S]*?)%>/g, "```javascript\n$&\n```");
  }
  if (import_obsidian6.MarkdownPreviewRenderer.codeBlockPostProcessors) {
    const codeblockProcessors = Object.keys(import_obsidian6.MarkdownPreviewRenderer.codeBlockPostProcessors);
    for (const codeblockProcessor of codeblockProcessors) {
      const regex = RegExp("^```" + codeblockProcessor + "[\\s\\S]*?```$", "gm");
      markdown = markdown.replace(regex, "<pre>$&</pre>");
    }
  } else {
    markdown = markdown.replace(/^```.*\n([\s\S]*?)```$/gm, "<pre>$&</pre>");
  }
  if (!plugin.settings.displayMedia) {
    markdown = markdown.replace(/!?\[(.*)\]\(.+\)/gm, "$1");
  }
  return markdown;
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// src/actions/Action.ts
var import_obsidian9 = __toModule(require("obsidian"));

// src/modals/TagModal.ts
var import_obsidian8 = __toModule(require("obsidian"));

// src/settings/suggest.ts
var import_obsidian7 = __toModule(require("obsidian"));

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element2) && includeScale) {
    var offsetHeight = element2.offsetHeight;
    var offsetWidth = element2.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance9 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance9.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance9.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance9.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance9.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2) {
  var rect = getBoundingClientRect(element2);
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance9 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance9.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance9
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance9.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance9;
    }
    instance9.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance9,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance9;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/settings/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on("click", ".suggestion-item", this.onSuggestionClick.bind(this));
    containerEl.on("mousemove", ".suggestion-item", this.onSuggestionMouseover.bind(this));
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values2) {
    this.containerEl.empty();
    const suggestionEls = [];
    values2.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values2;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(selectedIndex, this.suggestions.length);
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app, inputEl) {
    this.app = app;
    this.inputEl = inputEl;
    this.scope = new import_obsidian7.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on("mousedown", ".suggestion-container", (event) => {
      event.preventDefault();
    });
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance: instance9 }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance9.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/view/ArraySuggest.ts
var ArraySuggest = class extends TextInputSuggest {
  constructor(app, input, content) {
    super(app, input);
    this.content = content;
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLowerCase();
    return [...this.content].filter((content) => content.contains(lowerCaseInputStr));
  }
  renderSuggestion(content, el) {
    el.setText(content);
  }
  selectSuggestion(content) {
    this.inputEl.value = content;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/modals/TagModal.ts
var TagModal = class extends BaseModal {
  constructor(plugin, tags) {
    super(plugin.app);
    this.plugin = plugin;
    this.tags = tags;
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h1", { text: t("edit_tags") });
    const tagDiv = contentEl.createDiv("tags");
    for (const tag in this.tags) {
      new import_obsidian8.Setting(tagDiv).addSearch((search) => __async(this, null, function* () {
        new ArraySuggest(this.app, search.inputEl, get_store_value(tagsStore));
        search.setValue(this.tags[tag]).onChange((value) => __async(this, null, function* () {
          this.removeValidationError(search);
          if (!value.match(TAG_REGEX) || value.match(NUMBER_REGEX) || value.contains(" ") || value.contains("#")) {
            this.setValidationError(search, t("invalid_tag"));
            return;
          }
          this.tags = this.tags.filter((e) => e !== this.tags[tag]);
          this.tags.push(value);
        }));
      })).addExtraButton((button) => {
        button.setTooltip(t("delete")).setIcon("trash").onClick(() => {
          this.tags = this.tags.filter((e) => e !== this.tags[tag]);
          this.display();
        });
      });
    }
    let tagValue = "";
    let tagComponent;
    const newTag = new import_obsidian8.Setting(tagDiv).addSearch((search) => __async(this, null, function* () {
      tagComponent = search;
      new ArraySuggest(this.app, search.inputEl, get_store_value(tagsStore));
      search.onChange((value) => __async(this, null, function* () {
        if (!value.match(TAG_REGEX) || value.match(NUMBER_REGEX) || value.contains(" ") || value.contains("#")) {
          this.setValidationError(search, t("invalid_tag"));
          return;
        }
        tagValue = value;
      }));
    })).addExtraButton((button) => {
      button.setTooltip(t("add")).setIcon("plus").onClick(() => {
        if (!tagValue.match(TAG_REGEX) || tagValue.match(NUMBER_REGEX) || tagValue.contains(" ") || tagValue.contains("#")) {
          this.setValidationError(tagComponent, t("invalid_tag"));
          return;
        }
        this.tags.push(tagValue);
        this.display();
      });
    });
    newTag.controlEl.addClass("rss-setting-input");
    const buttonEl = contentEl.createSpan("actionButtons");
    new import_obsidian8.Setting(buttonEl).addExtraButton((btn) => btn.setTooltip(t("save")).setIcon("checkmark").onClick(() => __async(this, null, function* () {
      this.close();
    })));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  onOpen() {
    return __async(this, null, function* () {
      yield this.display();
    });
  }
};

// src/actions/Action.ts
var _Action = class {
  constructor(name, icon, processor) {
    this.name = name;
    this.icon = icon;
    this.processor = processor;
  }
};
var Action = _Action;
Action.CREATE_NOTE = new _Action(t("create_note"), "create-new", (plugin, item) => {
  return createNewNote(plugin, item);
});
Action.PASTE = new _Action(t("paste_to_note"), "paste", (plugin, item) => {
  return pasteToNote(plugin, item);
});
Action.COPY = new _Action(t("copy_to_clipboard"), "documents", (_, item) => {
  return copy((0, import_obsidian9.htmlToMarkdown)(item.content));
});
Action.OPEN = new _Action(t("open_browser"), "open-elsewhere-glyph", (_, item) => {
  openInBrowser(item);
  return Promise.resolve();
});
Action.TAGS = new _Action(t("edit_tags"), "tag-glyph", (plugin, item) => {
  const modal = new TagModal(plugin, item.tags);
  modal.onClose = () => __async(_Action, null, function* () {
    item.tags = modal.tags;
    const items = plugin.settings.items;
    yield plugin.writeFeedContent(() => {
      return items;
    });
  });
  modal.open();
  return Promise.resolve();
});
Action.READ = new _Action(t("mark_as_read_unread"), "eye", (plugin, item) => __async(_Action, null, function* () {
  if (item.read) {
    item.read = false;
    new import_obsidian9.Notice(t("marked_as_unread"));
  } else {
    item.read = true;
    new import_obsidian9.Notice(t("marked_as_read"));
  }
  const items = plugin.settings.items;
  yield plugin.writeFeedContent(() => {
    return items;
  });
  return Promise.resolve();
}));
Action.FAVORITE = new _Action(t("mark_as_favorite_remove"), "star", (plugin, item) => __async(_Action, null, function* () {
  if (item.favorite) {
    item.favorite = false;
    new import_obsidian9.Notice(t("removed_from_favorites"));
  } else {
    item.favorite = true;
    new import_obsidian9.Notice(t("added_to_favorites"));
  }
  const items = plugin.settings.items;
  yield plugin.writeFeedContent(() => {
    return items;
  });
  return Promise.resolve();
}));
Action.actions = Array.of(_Action.FAVORITE, _Action.READ, _Action.TAGS, _Action.CREATE_NOTE, _Action.PASTE, _Action.COPY, _Action.OPEN);

// src/modals/ItemModal.ts
var ItemModal = class extends import_obsidian10.Modal {
  constructor(plugin, item, items, save = true) {
    super(plugin.app);
    this.plugin = plugin;
    this.items = items;
    this.item = item;
    this.save = save;
    if (this.save) {
      this.item.read = true;
      const feedContents = this.plugin.settings.items;
      this.plugin.writeFeedContent(() => {
        return feedContents;
      });
      if (!this.plugin.settings) {
        return;
      }
      if (this.plugin.settings.hotkeys.read) {
        this.scope.register([], this.plugin.settings.hotkeys.read, () => {
          this.markAsRead();
        });
      }
      if (this.plugin.settings.hotkeys.favorite) {
        this.scope.register([], this.plugin.settings.hotkeys.favorite, () => {
          this.markAsFavorite();
        });
      }
      if (this.plugin.settings.hotkeys.tags) {
        this.scope.register([], this.plugin.settings.hotkeys.tags, () => {
          Action.TAGS.processor(this.plugin, this.item);
        });
      }
    }
    if (this.plugin.settings.hotkeys.create) {
      this.scope.register([], this.plugin.settings.hotkeys.create, () => {
        Action.CREATE_NOTE.processor(this.plugin, this.item);
      });
    }
    if (this.plugin.settings.hotkeys.paste) {
      this.scope.register([], this.plugin.settings.hotkeys.paste, () => {
        Action.PASTE.processor(this.plugin, this.item);
      });
    }
    if (this.plugin.settings.hotkeys.copy) {
      this.scope.register([], this.plugin.settings.hotkeys.copy, () => {
        Action.COPY.processor(this.plugin, this.item);
      });
    }
    if (this.plugin.settings.hotkeys.open) {
      this.scope.register([], this.plugin.settings.hotkeys.open, () => {
        Action.OPEN.processor(this.plugin, this.item);
      });
    }
    if (this.plugin.settings.hotkeys.next) {
      this.scope.register([], this.plugin.settings.hotkeys.next, () => {
        this.next();
      });
    }
    if (this.plugin.settings.hotkeys.previous) {
      this.scope.register([], this.plugin.settings.hotkeys.previous, () => {
        this.previous();
      });
    }
    if (this.app.plugins.plugins["obsidian-tts"] && this.plugin.settings.hotkeys.tts) {
      this.scope.register([], this.plugin.settings.hotkeys.tts, () => {
        const tts = this.app.plugins.plugins["obsidian-tts"].ttsService;
        if (tts.isSpeaking()) {
          if (tts.isPaused()) {
            tts.resume();
          } else {
            tts.pause();
          }
          return;
        }
        const content = (0, import_obsidian10.htmlToMarkdown)(this.item.content);
        tts.say(this.item.title, content, this.item.language);
      });
    }
  }
  previous() {
    let index = this.items.findIndex((item2) => {
      return item2 === this.item;
    });
    index++;
    const item = this.items[index];
    if (item !== void 0) {
      this.close();
      new ItemModal(this.plugin, item, this.items, this.save).open();
    }
  }
  next() {
    let index = this.items.findIndex((item2) => {
      return item2 === this.item;
    });
    index--;
    const item = this.items[index];
    if (item !== void 0) {
      this.close();
      new ItemModal(this.plugin, item, this.items, this.save).open();
    }
  }
  markAsFavorite() {
    return __async(this, null, function* () {
      yield Action.FAVORITE.processor(this.plugin, this.item);
      this.favoriteButton.setIcon(this.item.favorite ? "star-glyph" : "star");
      this.favoriteButton.setTooltip(this.item.favorite ? t("remove_from_favorites") : t("mark_as_favorite"));
    });
  }
  markAsRead() {
    return __async(this, null, function* () {
      yield Action.READ.processor(this.plugin, this.item);
      this.readButton.setIcon(this.item.read ? "eye-off" : "eye");
      this.readButton.setTooltip(this.item.read ? t("mark_as_unread") : t("mark_as_unread"));
    });
  }
  display() {
    return __async(this, null, function* () {
      this.modalEl.addClass("rss-modal");
      const { contentEl } = this;
      contentEl.empty();
      contentEl.style.height = "100%";
      contentEl.style.overflowY = "hidden";
      const topButtons = contentEl.createDiv("topButtons");
      let actions = Array.of(Action.CREATE_NOTE, Action.PASTE, Action.COPY, Action.OPEN);
      if (this.save) {
        this.readButton = new import_obsidian10.ButtonComponent(topButtons).setIcon(this.item.read ? "eye-off" : "eye").setTooltip(this.item.read ? t("mark_as_unread") : t("mark_as_read")).onClick(() => __async(this, null, function* () {
          yield this.markAsRead();
        }));
        this.readButton.buttonEl.setAttribute("tabindex", "-1");
        this.readButton.buttonEl.addClass("rss-button");
        this.favoriteButton = new import_obsidian10.ButtonComponent(topButtons).setIcon(this.item.favorite ? "star-glyph" : "star").setTooltip(this.item.favorite ? t("remove_from_favorites") : t("mark_as_favorite")).onClick(() => __async(this, null, function* () {
          yield this.markAsFavorite();
        }));
        this.favoriteButton.buttonEl.setAttribute("tabindex", "-1");
        this.favoriteButton.buttonEl.addClass("rss-button");
        actions = Array.of(Action.TAGS, ...actions);
      }
      actions.forEach((action) => {
        const button = new import_obsidian10.ButtonComponent(topButtons).setIcon(action.icon).setTooltip(action.name).onClick(() => __async(this, null, function* () {
          yield action.processor(this.plugin, this.item);
        }));
        button.buttonEl.setAttribute("tabindex", "-1");
        button.buttonEl.addClass("rss-button");
      });
      if (this.app.plugins.plugins["obsidian-tts"]) {
        const ttsButton = new import_obsidian10.ButtonComponent(topButtons).setIcon("headphones").setTooltip(t("read_article_tts")).onClick(() => __async(this, null, function* () {
          const content2 = (0, import_obsidian10.htmlToMarkdown)(this.item.content);
          yield this.app.plugins.plugins["obsidian-tts"].ttsService.say(this.item.title, content2, this.item.language);
        }));
        ttsButton.buttonEl.addClass("rss-button");
      }
      const prevButton = new import_obsidian10.ButtonComponent(topButtons).setIcon("left-arrow-with-tail").setTooltip(t("previous")).onClick(() => {
        this.previous();
      });
      prevButton.buttonEl.addClass("rss-button");
      const nextButton = new import_obsidian10.ButtonComponent(topButtons).setIcon("right-arrow-with-tail").setTooltip(t("next")).onClick(() => {
        this.next();
      });
      nextButton.buttonEl.addClass("rss-button");
      const title = contentEl.createEl("h1", "rss-title");
      title.addClass("rss-selectable");
      title.setText(this.item.title);
      const subtitle = contentEl.createEl("h3", "rss-subtitle");
      subtitle.addClass("rss-selectable");
      if (this.item.creator) {
        subtitle.appendText(this.item.creator);
      }
      if (this.item.pubDate) {
        subtitle.appendText(" - " + window.moment(this.item.pubDate).format(this.plugin.settings.dateFormat));
      }
      const tagEl = contentEl.createSpan("tags");
      this.item.tags.forEach((tag) => {
        const tagA = tagEl.createEl("a");
        tagA.setText(tag);
        tagA.addClass("tag", "rss-tag");
      });
      const content = contentEl.createDiv("rss-content");
      content.addClass("rss-scrollable-content", "rss-selectable");
      if (this.item.enclosure && this.plugin.settings.displayMedia) {
        if (this.item.enclosureType.toLowerCase().contains("audio")) {
          const audio = content.createEl("audio", { attr: { controls: "controls" } });
          audio.createEl("source", { attr: { src: this.item.enclosure, type: this.item.enclosureType } });
        }
        if (this.item.enclosureType.toLowerCase().contains("video")) {
          const video = content.createEl("video", { attr: { controls: "controls", width: "100%", height: "100%" } });
          video.createEl("source", { attr: { src: this.item.enclosure, type: this.item.enclosureType } });
        }
        if (this.item.enclosure && this.item.id.startsWith("yt:")) {
          content.createEl("iframe", {
            attr: {
              type: "text/html",
              src: "https://www.youtube.com/embed/" + this.item.enclosure,
              width: "100%",
              height: "100%",
              allowFullscreen: "true"
            }
          });
        }
      }
      if (this.item.content) {
        const markdown = "---\n---" + rssToMd(this.plugin, this.item.content);
        yield import_obsidian10.MarkdownRenderer.renderMarkdown(markdown, content, "", this.plugin);
        this.item.highlights.forEach((highlight) => {
          if (content.innerHTML.includes(highlight)) {
            const newNode = contentEl.createEl("mark");
            newNode.innerHTML = highlight;
            content.innerHTML = content.innerHTML.replace(highlight, newNode.outerHTML);
            newNode.remove();
          } else {
            console.log("Highlight not included");
            console.log(highlight);
          }
        });
        content.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          const selection = document.getSelection();
          const range = selection.getRangeAt(0);
          const div = contentEl.createDiv();
          const htmlContent = range.cloneContents();
          const html = htmlContent.cloneNode(true);
          div.appendChild(html);
          const selected = div.innerHTML;
          div.remove();
          const menu = new import_obsidian10.Menu(this.app);
          let previousHighlight;
          if (this.item.highlights.includes(range.startContainer.parentElement.innerHTML)) {
            previousHighlight = range.startContainer.parentElement;
          }
          if (this.item.highlights.includes(range.startContainer.parentElement.parentElement.innerHTML)) {
            previousHighlight = range.startContainer.parentElement.parentElement;
          }
          if (previousHighlight) {
            menu.addItem((item) => {
              item.setIcon("highlight-glyph").setTitle(t("highlight_remove")).onClick(() => __async(this, null, function* () {
                const replacement = contentEl.createSpan();
                replacement.innerHTML = previousHighlight.innerHTML;
                previousHighlight.replaceWith(replacement);
                this.item.highlights.remove(previousHighlight.innerHTML);
                const feedContents = this.plugin.settings.items;
                yield this.plugin.writeFeedContent(() => {
                  return feedContents;
                });
              }));
            });
          } else if (!this.item.highlights.includes(selected) && selected.length > 0) {
            menu.addItem((item) => {
              item.setIcon("highlight-glyph").setTitle(t("highlight")).onClick(() => __async(this, null, function* () {
                const newNode = contentEl.createEl("mark");
                newNode.innerHTML = selected;
                range.deleteContents();
                range.insertNode(newNode);
                this.item.highlights.push(selected);
                const feedContents = this.plugin.settings.items;
                yield this.plugin.writeFeedContent(() => {
                  return feedContents;
                });
                this.removeDanglingElements(contentEl);
                this.removeDanglingElements(contentEl);
              }));
            });
          }
          if (selected.length > 0) {
            menu.addItem((item) => {
              item.setIcon("documents").setTitle(t("copy_to_clipboard")).onClick(() => __async(this, null, function* () {
                yield copy(selection.toString());
              }));
            });
            if (this.app.plugins.plugins["obsidian-tts"]) {
              menu.addItem((item) => {
                item.setIcon("headphones").setTitle(t("read_article_tts")).onClick(() => {
                  const tts = this.app.plugins.plugins["obsidian-tts"].ttsService;
                  tts.say("", selection.toString());
                });
              });
            }
          }
          menu.showAtMouseEvent(event);
        });
      }
    });
  }
  onClose() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      const feedContents = this.plugin.settings.items;
      yield this.plugin.writeFeedContent(() => {
        return feedContents;
      });
    });
  }
  onOpen() {
    return __async(this, null, function* () {
      yield this.display();
    });
  }
  removeDanglingElements(el) {
    const lists = el.querySelectorAll("li, a, div, p, span");
    for (let i = 0; i < lists.length; i++) {
      const listEL = lists.item(i);
      if (listEL.innerHTML === "") {
        listEL.remove();
      }
    }
  }
};

// src/view/ItemTitle.svelte
var import_obsidian11 = __toModule(require("obsidian"));
function create_if_block_1(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({ props: { iconName: "star" } });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block3(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({ props: { iconName: "document" } });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_fragment3(ctx) {
  let t0;
  let t1;
  let a;
  let t2_value = ctx[1].title + "";
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1].favorite && create_if_block_1(ctx);
  let if_block1 = ctx[1].created && create_if_block3(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      a = element("a");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, a, anchor);
      append(a, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", ctx[4]),
          listen(a, "contextmenu", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[1].favorite) {
        if (if_block0) {
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[1].created) {
        if (if_block1) {
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ((!current || dirty & 2) && t2_value !== (t2_value = ctx2[1].title + ""))
        set_data(t2, t2_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(a);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { plugin = null } = $$props;
  let { item = null } = $$props;
  let { items = null } = $$props;
  function openMenu(e) {
    return __async(this, null, function* () {
      if (e.ctrlKey && e.altKey) {
        openInBrowser(item);
        return;
      }
      if (e.ctrlKey) {
        yield createNewNote(plugin, item);
        return;
      }
      if (e.altKey) {
        yield pasteToNote(plugin, item);
        return;
      }
      const menu = new import_obsidian11.Menu(plugin.app);
      Action.actions.forEach((action) => {
        menu.addItem((menuItem) => {
          menuItem.setIcon(action.icon).setTitle(action.name).onClick(() => __async(this, null, function* () {
            yield action.processor(plugin, item);
          }));
        });
      });
      menu.showAtPosition({ x: e.x, y: e.y });
    });
  }
  const click_handler = () => {
    new ItemModal(plugin, item, items).open();
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("items" in $$props2)
      $$invalidate(2, items = $$props2.items);
  };
  return [plugin, item, items, openMenu, click_handler];
}
var ItemTitle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { plugin: 0, item: 1, items: 2 });
  }
};
var ItemTitle_default = ItemTitle;

// src/view/MarkdownContent.svelte
var import_obsidian12 = __toModule(require("obsidian"));
function create_if_block4(ctx) {
  let p;
  let html_action;
  let mounted;
  let dispose;
  return {
    c() {
      p = element("p");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      if (!mounted) {
        dispose = action_destroyer(html_action = ctx[1].call(null, p, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (html_action && is_function(html_action.update) && dirty & 1)
        html_action.update.call(null, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let if_block = ctx[0].length > 0 && create_if_block4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { content = "" } = $$props;
  let { plugin } = $$props;
  const html = (node, content2) => {
    import_obsidian12.MarkdownRenderer.renderMarkdown((0, import_obsidian12.htmlToMarkdown)(content2), node, "", plugin);
  };
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
    if ("plugin" in $$props2)
      $$invalidate(2, plugin = $$props2.plugin);
  };
  return [content, html, plugin];
}
var MarkdownContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { content: 0, plugin: 2 });
  }
};
var MarkdownContent_default = MarkdownContent;

// src/view/ItemView.svelte
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block_12, create_if_block_5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].displayStyle === "list")
      return 0;
    if (ctx2[4].displayStyle === "cards")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", div_class_value = "is-clickable rss-tooltip rss-feed-item " + (ctx[1].read ? "rss-read" : "rss-not-read"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty & 2 && div_class_value !== (div_class_value = "is-clickable rss-tooltip rss-feed-item " + (ctx2[1].read ? "rss-read" : "rss-not-read"))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_5(ctx) {
  let div3;
  let span;
  let itemtitle;
  let t0;
  let t1;
  let div2;
  let div0;
  let show_if = ctx[1].image && !ctx[1].image.includes(".mp3");
  let t2;
  let div1;
  let current;
  itemtitle = new ItemTitle_default({
    props: {
      plugin: ctx[0],
      item: ctx[1],
      items: ctx[2]
    }
  });
  itemtitle.$on("mouseover", ctx[5]);
  itemtitle.$on("mouseleave", ctx[5]);
  itemtitle.$on("focus", ctx[5]);
  let if_block0 = ctx[1].tags.length > 0 && create_if_block_8(ctx);
  let if_block1 = show_if && create_if_block_7(ctx);
  let if_block2 = ctx[1].description && create_if_block_6(ctx);
  return {
    c() {
      div3 = element("div");
      span = element("span");
      create_component(itemtitle.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      if (if_block2)
        if_block2.c();
      attr(span, "class", "rss-item-title");
      attr(div0, "class", "rss-item-image");
      attr(div1, "class", "rss-item-text");
      attr(div2, "class", "rss-card-items");
      attr(div3, "class", "rss-card is-clickable");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, span);
      mount_component(itemtitle, span, null);
      append(span, t0);
      if (if_block0)
        if_block0.m(span, null);
      append(div3, t1);
      append(div3, div2);
      append(div2, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append(div2, t2);
      append(div2, div1);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtitle_changes = {};
      if (dirty & 1)
        itemtitle_changes.plugin = ctx2[0];
      if (dirty & 2)
        itemtitle_changes.item = ctx2[1];
      if (dirty & 4)
        itemtitle_changes.items = ctx2[2];
      itemtitle.$set(itemtitle_changes);
      if (ctx2[1].tags.length > 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          if_block0.m(span, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 2)
        show_if = ctx2[1].image && !ctx2[1].image.includes(".mp3");
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[1].description) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_6(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(itemtitle.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(itemtitle.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(itemtitle);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_12(ctx) {
  let itemtitle;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  itemtitle = new ItemTitle_default({
    props: {
      plugin: ctx[0],
      item: ctx[1],
      items: ctx[2]
    }
  });
  itemtitle.$on("mouseover", ctx[5]);
  itemtitle.$on("mouseleave", ctx[5]);
  itemtitle.$on("focus", ctx[5]);
  let if_block0 = ctx[1].tags.length > 0 && create_if_block_4(ctx);
  let if_block1 = ctx[3] && create_if_block_2(ctx);
  return {
    c() {
      create_component(itemtitle.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtitle, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtitle_changes = {};
      if (dirty & 1)
        itemtitle_changes.plugin = ctx2[0];
      if (dirty & 2)
        itemtitle_changes.item = ctx2[1];
      if (dirty & 4)
        itemtitle_changes.items = ctx2[2];
      itemtitle.$set(itemtitle_changes);
      if (ctx2[1].tags.length > 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(itemtitle.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(itemtitle.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtitle, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_if_block_8(ctx) {
  let span;
  let each_value_1 = ctx[1].tags;
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span, null);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value_1 = ctx2[1].tags;
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let t0;
  let a;
  let t1_value = ctx[6] + "";
  let t1;
  let a_href_value;
  return {
    c() {
      t0 = text("\xA0");
      a = element("a");
      t1 = text(t1_value);
      attr(a, "class", "tag rss-tag");
      attr(a, "href", a_href_value = "#" + ctx[6]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, a, anchor);
      append(a, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[6] + ""))
        set_data(t1, t1_value);
      if (dirty & 2 && a_href_value !== (a_href_value = "#" + ctx2[6])) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_7(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[1].image))
        attr(img, "src", img_src_value);
      attr(img, "width", "250em");
      attr(img, "alt", "Article");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && !src_url_equal(img.src, img_src_value = ctx2[1].image)) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_6(ctx) {
  let markdowncontent;
  let current;
  markdowncontent = new MarkdownContent_default({
    props: { content: ctx[1].description }
  });
  return {
    c() {
      create_component(markdowncontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(markdowncontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const markdowncontent_changes = {};
      if (dirty & 2)
        markdowncontent_changes.content = ctx2[1].description;
      markdowncontent.$set(markdowncontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdowncontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdowncontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(markdowncontent, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  let each_value = ctx[1].tags;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span, null);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1].tags;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let t0;
  let a;
  let t1_value = ctx[6] + "";
  let t1;
  let a_href_value;
  return {
    c() {
      t0 = text("\xA0");
      a = element("a");
      t1 = text(t1_value);
      attr(a, "class", "tag rss-tag");
      attr(a, "href", a_href_value = "#" + ctx[6]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, a, anchor);
      append(a, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[6] + ""))
        set_data(t1, t1_value);
      if (dirty & 2 && a_href_value !== (a_href_value = "#" + ctx2[6])) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1].description !== ctx[1].content && create_if_block_3(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1].description !== ctx2[1].content) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let htmltooltip;
  let current;
  htmltooltip = new HtmlTooltip_default({
    props: { content: ctx[1].description }
  });
  return {
    c() {
      create_component(htmltooltip.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmltooltip, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const htmltooltip_changes = {};
      if (dirty & 2)
        htmltooltip_changes.content = ctx2[1].description;
      htmltooltip.$set(htmltooltip_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(htmltooltip.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmltooltip.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmltooltip, detaching);
    }
  };
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block5(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let $settingsStore;
  component_subscribe($$self, settingsStore, ($$value) => $$invalidate(4, $settingsStore = $$value));
  let { plugin = null } = $$props;
  let { item = null } = $$props;
  let { items = null } = $$props;
  let hover = false;
  function toggleHover() {
    $$invalidate(3, hover = !hover);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("items" in $$props2)
      $$invalidate(2, items = $$props2.items);
  };
  return [plugin, item, items, hover, $settingsStore, toggleHover];
}
var ItemView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { plugin: 0, item: 1, items: 2 });
  }
};
var ItemView_default = ItemView;

// src/view/FeedView.svelte
var import_obsidian13 = __toModule(require("obsidian"));
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let div3;
  let div1;
  let div0;
  let show_if_1;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span0;
  let t1_value = ctx[0].name + "";
  let t1;
  let t2;
  let t3;
  let span1;
  let t4_value = ctx[0].items.filter(func).length + "";
  let t4;
  let div1_class_value;
  let t5;
  let div2;
  let show_if = !ctx[2].contains(ctx[0].name);
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_32, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & 5)
      show_if_1 = null;
    if (show_if_1 == null)
      show_if_1 = !!ctx2[2].contains(ctx2[0].name);
    if (show_if_1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[0].image && create_if_block_22(ctx);
  let if_block2 = show_if && create_if_block_13(ctx);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      t5 = space();
      div2 = element("div");
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "rss-feed-title");
      set_style(div0, "overflow", "hidden");
      attr(span1, "class", "rss-item-count");
      attr(div1, "class", div1_class_value = "" + ((ctx[2].contains(ctx[0].name) ? "is-collapsed" : "") + " tree-item-self is-clickable"));
      attr(div2, "class", "rss-feed-items");
      attr(div3, "class", "rss-feed");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t0);
      append(div0, span0);
      append(span0, t1);
      append(span0, t2);
      if (if_block1)
        if_block1.m(span0, null);
      append(div1, t3);
      append(div1, span1);
      append(span1, t4);
      append(div3, t5);
      append(div3, div2);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "click", ctx[5]),
          listen(div1, "contextmenu", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, t0);
      }
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].name + ""))
        set_data(t1, t1_value);
      if (ctx2[0].image) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          if_block1.m(span0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty & 1) && t4_value !== (t4_value = ctx2[0].items.filter(func).length + ""))
        set_data(t4, t4_value);
      if (!current || dirty & 5 && div1_class_value !== (div1_class_value = "" + ((ctx2[2].contains(ctx2[0].name) ? "is-collapsed" : "") + " tree-item-self is-clickable"))) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & 5)
        show_if = !ctx2[2].contains(ctx2[0].name);
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_13(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block6(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "...loading";
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_else_block_1(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "down-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "right-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[0].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = ctx[0].title);
      set_style(img, "height", "1em");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && !src_url_equal(img.src, img_src_value = ctx2[0].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 1 && img_alt_value !== (img_alt_value = ctx2[0].title)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_13(ctx) {
  let div;
  let current;
  let each_value = ctx[0].items;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[0].items;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let div1;
  let div0;
  let itemview;
  let t_1;
  let current;
  itemview = new ItemView_default({
    props: {
      item: ctx[6],
      plugin: ctx[1],
      items: ctx[0].items
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(itemview.$$.fragment);
      t_1 = space();
      attr(div0, "class", "tree-item-self");
      attr(div1, "class", "tree-item");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(itemview, div0, null);
      append(div1, t_1);
      current = true;
    },
    p(ctx2, dirty) {
      const itemview_changes = {};
      if (dirty & 1)
        itemview_changes.item = ctx2[6];
      if (dirty & 2)
        itemview_changes.plugin = ctx2[1];
      if (dirty & 1)
        itemview_changes.items = ctx2[0].items;
      itemview.$set(itemview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(itemview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(itemview);
    }
  };
}
function create_fragment6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
var func = (item) => !item.read;
function instance6($$self, $$props, $$invalidate) {
  let { feed = null } = $$props;
  let { plugin } = $$props;
  let folded = [];
  foldedState.subscribe((value) => {
    $$invalidate(2, folded = value);
  });
  function toggleFold(feed2) {
    if (!folded) {
      $$invalidate(2, folded = []);
    }
    if (folded.contains(feed2)) {
      folded.remove(feed2);
    } else
      folded.push(feed2);
    plugin.writeFolded(folded);
  }
  function openMenu(e) {
    return __async(this, null, function* () {
      const menu = new import_obsidian13.Menu(plugin.app);
      menu.addItem((menuItem) => {
        menuItem.setIcon("create-new").setTitle(t("create_all")).onClick(() => __async(this, null, function* () {
          for (let item of feed.items) {
            yield Action.CREATE_NOTE.processor(plugin, item);
          }
        }));
      });
      menu.addItem((menuItem) => {
        menuItem.setIcon("feather-eye").setTitle(t("mark_all_as_read")).onClick(() => __async(this, null, function* () {
          for (let item of feed.items) {
            item.read = true;
          }
          const items = plugin.settings.items;
          yield plugin.writeFeedContent(() => {
            return items;
          });
        }));
      });
      menu.addItem((menuItem) => {
        menuItem.setIcon("tag-glyph").setTitle(t("add_tags_to_all")).onClick(() => __async(this, null, function* () {
          const tagModal = new TagModal(plugin, []);
          tagModal.onClose = () => __async(this, null, function* () {
            for (let item of feed.items) {
              item.tags.push(...tagModal.tags);
            }
            const items = plugin.settings.items;
            yield plugin.writeFeedContent(() => {
              return items;
            });
          });
          tagModal.open();
        }));
      });
      menu.showAtPosition({ x: e.x, y: e.y });
    });
  }
  const click_handler = () => toggleFold(feed.name);
  $$self.$$set = ($$props2) => {
    if ("feed" in $$props2)
      $$invalidate(0, feed = $$props2.feed);
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
  };
  return [feed, plugin, folded, toggleFold, openMenu, click_handler];
}
var FeedView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { feed: 0, plugin: 1 });
  }
};
var FeedView_default = FeedView;

// src/view/FolderView.svelte
var import_obsidian15 = __toModule(require("obsidian"));

// src/view/TopRowButtons.svelte
var import_obsidian14 = __toModule(require("obsidian"));
function create_fragment7(ctx) {
  let span;
  let buttons_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(buttons_action = ctx[1].call(null, span, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (buttons_action && is_function(buttons_action.update) && dirty & 1)
        buttons_action.update.call(null, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  const buttons = (node, plugin2) => {
    new import_obsidian14.Setting(node).addExtraButton((button) => {
      button.setIcon("refresh-cw").setTooltip(t("refresh_feeds")).onClick(() => __async(this, null, function* () {
        yield plugin2.updateFeeds();
      }));
    });
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [plugin, buttons];
}
var TopRowButtons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { plugin: 0 });
  }
};
var TopRowButtons_default = TopRowButtons;

// src/view/FolderView.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  return child_ctx;
}
function create_else_block2(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = ctx[3] && create_if_block_9(ctx);
  let if_block1 = !ctx[2] && create_if_block_82(ctx);
  let if_block2 = ctx[2] && create_if_block_110(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "rss-view");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_82(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_110(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block7(ctx) {
  let h1;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = `${t("loading")}`;
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(h1);
    }
  };
}
function create_if_block_9(ctx) {
  let div1;
  let div0;
  let span;
  let show_if_1;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div0_class_value;
  let t1;
  let show_if = !ctx[1].contains("rss-filters");
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_20, create_else_block_8];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & 2)
      show_if_1 = null;
    if (show_if_1 == null)
      show_if_1 = !!ctx2[1].contains("rss-filters");
    if (show_if_1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[4].renamedText.filtered_folders !== "")
      return create_if_block_19;
    return create_else_block_7;
  }
  let current_block_type = select_block_type_2(ctx, -1);
  let if_block1 = current_block_type(ctx);
  let if_block2 = show_if && create_if_block_10(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(span, "class", "tree-item-self is-clickable");
      attr(div0, "class", div0_class_value = "" + ((ctx[1].contains("rss-filters") ? "is-collapsed" : "") + " tree-item is-clickable"));
      attr(div1, "class", "rss-filtered-folders");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span);
      if_blocks[current_block_type_index].m(span, null);
      append(span, t0);
      if_block1.m(span, null);
      append(div1, t1);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
        }
        transition_in(if_block0, 1);
        if_block0.m(span, t0);
      }
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(span, null);
        }
      }
      if (!current || dirty & 2 && div0_class_value !== (div0_class_value = "" + ((ctx2[1].contains("rss-filters") ? "is-collapsed" : "") + " tree-item is-clickable"))) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & 2)
        show_if = !ctx2[1].contains("rss-filters");
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_10(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_8(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "down-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_20(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "right-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_else_block_7(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${t("filtered_folders")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_19(ctx) {
  let span;
  let t_1_value = ctx[4].renamedText.filtered_folders + "";
  let t_1;
  return {
    c() {
      span = element("span");
      t_1 = text(t_1_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_1_value !== (t_1_value = ctx2[4].renamedText.filtered_folders + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_10(ctx) {
  let span;
  let current;
  let each_value_2 = buildTreeStructure(ctx[3]);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 171) {
        each_value_2 = buildTreeStructure(ctx2[3]);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(span, null);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block_6(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "down-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_18(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "right-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_16(ctx) {
  let show_if = !ctx[1].contains("rss-filters-" + ctx[15].name);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_17(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 10)
        show_if = !ctx2[1].contains("rss-filters-" + ctx2[15].name);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 10) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_17(ctx) {
  let div;
  let current;
  let each_value_5 = ctx[15].filter.items.items;
  let each_blocks = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 9) {
        each_value_5 = ctx2[15].filter.items.items;
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_5.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_5(ctx) {
  let div1;
  let div0;
  let itemview;
  let t_1;
  let current;
  itemview = new ItemView_default({
    props: {
      item: ctx[26],
      plugin: ctx[0],
      items: ctx[15].filter.items.items
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(itemview.$$.fragment);
      t_1 = space();
      attr(div0, "class", "tree-item-self");
      attr(div1, "class", "tree-item");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(itemview, div0, null);
      append(div1, t_1);
      current = true;
    },
    p(ctx2, dirty) {
      const itemview_changes = {};
      if (dirty & 8)
        itemview_changes.item = ctx2[26];
      if (dirty & 1)
        itemview_changes.plugin = ctx2[0];
      if (dirty & 8)
        itemview_changes.items = ctx2[15].filter.items.items;
      itemview.$set(itemview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(itemview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(itemview);
    }
  };
}
function create_if_block_11(ctx) {
  let show_if = !ctx[1].contains("rss-filters-" + ctx[15].name);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_122(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 10)
        show_if = !ctx2[1].contains("rss-filters-" + ctx2[15].name);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 10) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_122(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_122(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = ctx[15].children;
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 43) {
        each_value_3 = ctx2[15].children;
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_else_block_5(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "down-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "right-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_132(ctx) {
  let show_if = !ctx[1].contains("rss-filters-" + ctx[23].filter.filter.name);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_14(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 10)
        show_if = !ctx2[1].contains("rss-filters-" + ctx2[23].filter.filter.name);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 10) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_14(ctx) {
  let div;
  let current;
  let each_value_4 = ctx[23].filter.items.items;
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 9) {
        each_value_4 = ctx2[23].filter.items.items;
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_4.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_4(ctx) {
  let div1;
  let div0;
  let itemview;
  let t_1;
  let current;
  itemview = new ItemView_default({
    props: {
      item: ctx[26],
      plugin: ctx[0],
      items: ctx[23].filter.items.items
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(itemview.$$.fragment);
      t_1 = space();
      attr(div0, "class", "tree-item-self");
      attr(div1, "class", "tree-item");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(itemview, div0, null);
      append(div1, t_1);
      current = true;
    },
    p(ctx2, dirty) {
      const itemview_changes = {};
      if (dirty & 8)
        itemview_changes.item = ctx2[26];
      if (dirty & 1)
        itemview_changes.plugin = ctx2[0];
      if (dirty & 8)
        itemview_changes.items = ctx2[23].filter.items.items;
      itemview.$set(itemview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(itemview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(itemview);
    }
  };
}
function create_each_block_3(ctx) {
  var _a;
  let div1;
  let div0;
  let show_if;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span0;
  let t1_value = ctx[23].name + "";
  let t1;
  let t2;
  let span1;
  let t3_value = ((_a = ctx[23].filter) == null ? void 0 : _a.items.items.length) + "";
  let t3;
  let div0_class_value;
  let t4;
  let t5;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_15, create_else_block_5];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (dirty & 10)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[1].contains("rss-filters-" + ctx2[23].filter.filter.name);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function click_handler_2() {
    return ctx[11](ctx[23]);
  }
  let if_block1 = ctx[23].filter !== void 0 && create_if_block_132(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      span1 = element("span");
      t3 = text(t3_value);
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      attr(span1, "class", "rss-item-count");
      attr(div0, "class", div0_class_value = "" + ((ctx[1].contains("rss-filters-" + ctx[23].filter.filter.name) ? "is-collapsed" : "") + " tree-item-self is-clickable"));
      attr(div1, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t0);
      append(div0, span0);
      append(span0, t1);
      append(div0, t2);
      append(div0, span1);
      append(span1, t3);
      append(div1, t4);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t5);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        } else {
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, t0);
      }
      if ((!current || dirty & 8) && t1_value !== (t1_value = ctx[23].name + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 8) && t3_value !== (t3_value = ((_a2 = ctx[23].filter) == null ? void 0 : _a2.items.items.length) + ""))
        set_data(t3, t3_value);
      if (!current || dirty & 10 && div0_class_value !== (div0_class_value = "" + ((ctx[1].contains("rss-filters-" + ctx[23].filter.filter.name) ? "is-collapsed" : "") + " tree-item-self is-clickable"))) {
        attr(div0, "class", div0_class_value);
      }
      if (ctx[23].filter !== void 0) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_132(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t5);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_2(ctx) {
  var _a;
  let div1;
  let div0;
  let span2;
  let show_if;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span0;
  let t1_value = ctx[15].name + "";
  let t1;
  let t2;
  let span1;
  let t3_value = ((_a = ctx[15].filter) == null ? void 0 : _a.items.items.length) + "";
  let t3;
  let div0_class_value;
  let t4;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_18, create_else_block_6];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (dirty & 10)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[1].contains("rss-filters-" + ctx2[15].name);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function contextmenu_handler(...args) {
    return ctx[9](ctx[15], ...args);
  }
  function click_handler_1() {
    return ctx[10](ctx[15]);
  }
  let if_block1 = ctx[15].filter !== void 0 && create_if_block_16(ctx);
  let if_block2 = ctx[15].children && create_if_block_11(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span2 = element("span");
      if_block0.c();
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      span1 = element("span");
      t3 = text(t3_value);
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      if (if_block2)
        if_block2.c();
      t6 = space();
      attr(span1, "class", "rss-item-count");
      attr(span2, "class", "tree-item-self is-clickable");
      attr(div0, "class", div0_class_value = "" + ((ctx[1].contains("rss-filters-" + ctx[15].name) ? "is-collapsed" : "") + " tree-item is-clickable"));
      attr(div1, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span2);
      if_blocks[current_block_type_index].m(span2, null);
      append(span2, t0);
      append(span2, span0);
      append(span0, t1);
      append(span2, t2);
      append(span2, span1);
      append(span1, t3);
      append(div1, t4);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t5);
      if (if_block2)
        if_block2.m(div1, null);
      append(div1, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span2, "contextmenu", contextmenu_handler),
          listen(div0, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        } else {
        }
        transition_in(if_block0, 1);
        if_block0.m(span2, t0);
      }
      if ((!current || dirty & 8) && t1_value !== (t1_value = ctx[15].name + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 8) && t3_value !== (t3_value = ((_a2 = ctx[15].filter) == null ? void 0 : _a2.items.items.length) + ""))
        set_data(t3, t3_value);
      if (!current || dirty & 10 && div0_class_value !== (div0_class_value = "" + ((ctx[1].contains("rss-filters-" + ctx[15].name) ? "is-collapsed" : "") + " tree-item is-clickable"))) {
        attr(div0, "class", div0_class_value);
      }
      if (ctx[15].filter !== void 0) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_16(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t5);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx[15].children) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_11(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t6);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_82(ctx) {
  let h1;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = `${t("loading")}`;
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(h1);
    }
  };
}
function create_if_block_110(ctx) {
  let div1;
  let div0;
  let span;
  let show_if_1;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div0_class_value;
  let t1;
  let show_if = !ctx[1].contains("rss-folders");
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_72, create_else_block_4];
  const if_blocks = [];
  function select_block_type_5(ctx2, dirty) {
    if (dirty & 2)
      show_if_1 = null;
    if (show_if_1 == null)
      show_if_1 = !!ctx2[1].contains("rss-folders");
    if (show_if_1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_5(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function select_block_type_6(ctx2, dirty) {
    if (ctx2[4].renamedText.folders !== "")
      return create_if_block_62;
    return create_else_block_3;
  }
  let current_block_type = select_block_type_6(ctx, -1);
  let if_block1 = current_block_type(ctx);
  let if_block2 = show_if && create_if_block_23(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(span, "class", "tree-item-self is-clickable");
      attr(div0, "class", div0_class_value = "" + ((ctx[1].contains("rss-folders") ? "is-collapsed" : "") + " tree-item is-clickable"));
      attr(div1, "class", "rss-feeds-folders");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span);
      if_blocks[current_block_type_index].m(span, null);
      append(span, t0);
      if_block1.m(span, null);
      append(div1, t1);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_5(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
        }
        transition_in(if_block0, 1);
        if_block0.m(span, t0);
      }
      if (current_block_type === (current_block_type = select_block_type_6(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(span, null);
        }
      }
      if (!current || dirty & 2 && div0_class_value !== (div0_class_value = "" + ((ctx2[1].contains("rss-folders") ? "is-collapsed" : "") + " tree-item is-clickable"))) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & 2)
        show_if = !ctx2[1].contains("rss-folders");
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_23(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_4(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "down-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_72(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "right-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_else_block_3(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${t("folders")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_62(ctx) {
  let span;
  let t_1_value = ctx[4].renamedText.folders + "";
  let t_1;
  return {
    c() {
      span = element("span");
      t_1 = text(t_1_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_1_value !== (t_1_value = ctx2[4].renamedText.folders + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_23(ctx) {
  let div;
  let current;
  let each_value = Object.keys(ctx[2]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 119) {
        each_value = Object.keys(ctx2[2]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block_2(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "down-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_if_block_52(ctx) {
  let iconcomponent;
  let current;
  iconcomponent = new IconComponent_default({
    props: { iconName: "right-chevron-glyph" }
  });
  return {
    c() {
      create_component(iconcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconcomponent, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconcomponent, detaching);
    }
  };
}
function create_else_block_12(ctx) {
  let span;
  let t_1_value = (ctx[4].renamedText.no_folder !== "" ? ctx[4].renamedText.no_folder : t("no_folder")) + "";
  let t_1;
  return {
    c() {
      span = element("span");
      t_1 = text(t_1_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_1_value !== (t_1_value = (ctx2[4].renamedText.no_folder !== "" ? ctx2[4].renamedText.no_folder : t("no_folder")) + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_42(ctx) {
  let span;
  let t_1_value = ctx[15] + "";
  let t_1;
  return {
    c() {
      span = element("span");
      t_1 = text(t_1_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_1_value !== (t_1_value = ctx2[15] + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_33(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[2][ctx[15]];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value_1 = ctx2[2][ctx2[15]];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_12(ctx) {
  let feedview;
  let current;
  feedview = new FeedView_default({
    props: {
      feed: ctx[18],
      plugin: ctx[0]
    }
  });
  return {
    c() {
      create_component(feedview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(feedview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const feedview_changes = {};
      if (dirty & 4)
        feedview_changes.feed = ctx2[18];
      if (dirty & 1)
        feedview_changes.plugin = ctx2[0];
      feedview.$set(feedview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(feedview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(feedview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(feedview, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let div1;
  let span;
  let show_if_1;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span_class_value;
  let t1;
  let div0;
  let show_if = !ctx[1].contains(ctx[15]);
  let t2;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_52, create_else_block_2];
  const if_blocks = [];
  function select_block_type_7(ctx2, dirty) {
    if (dirty & 6)
      show_if_1 = null;
    if (show_if_1 == null)
      show_if_1 = !!ctx2[1].contains(ctx2[15]);
    if (show_if_1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_7(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function select_block_type_8(ctx2, dirty) {
    if (ctx2[15])
      return create_if_block_42;
    return create_else_block_12;
  }
  let current_block_type = select_block_type_8(ctx, -1);
  let if_block1 = current_block_type(ctx);
  function click_handler_4() {
    return ctx[13](ctx[15]);
  }
  function contextmenu_handler_1(...args) {
    return ctx[14](ctx[15], ...args);
  }
  let if_block2 = show_if && create_if_block_33(ctx);
  return {
    c() {
      div1 = element("div");
      span = element("span");
      if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      attr(span, "class", span_class_value = "" + ((ctx[1].contains(ctx[15]) ? "is-collapsed" : "") + " tree-item-self is-clickable"));
      attr(div0, "class", "tree-item-children");
      attr(div1, "class", "rss-folder tree-item");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      if_blocks[current_block_type_index].m(span, null);
      append(span, t0);
      if_block1.m(span, null);
      append(div1, t1);
      append(div1, div0);
      if (if_block2)
        if_block2.m(div0, null);
      append(div1, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span, "click", click_handler_4),
          listen(span, "contextmenu", contextmenu_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_7(ctx, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        } else {
        }
        transition_in(if_block0, 1);
        if_block0.m(span, t0);
      }
      if (current_block_type === (current_block_type = select_block_type_8(ctx, dirty)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx);
        if (if_block1) {
          if_block1.c();
          if_block1.m(span, null);
        }
      }
      if (!current || dirty & 6 && span_class_value !== (span_class_value = "" + ((ctx[1].contains(ctx[15]) ? "is-collapsed" : "") + " tree-item-self is-clickable"))) {
        attr(span, "class", span_class_value);
      }
      if (dirty & 6)
        show_if = !ctx[1].contains(ctx[15]);
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & 6) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_33(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment8(ctx) {
  let toprowbuttons;
  let t_1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  toprowbuttons = new TopRowButtons_default({ props: { plugin: ctx[0] } });
  const if_block_creators = [create_if_block7, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(toprowbuttons.$$.fragment);
      t_1 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(toprowbuttons, target, anchor);
      insert(target, t_1, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const toprowbuttons_changes = {};
      if (dirty & 1)
        toprowbuttons_changes.plugin = ctx2[0];
      toprowbuttons.$set(toprowbuttons_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(toprowbuttons.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(toprowbuttons.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(toprowbuttons, detaching);
      if (detaching)
        detach(t_1);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function buildTreeStructure(filteredContent) {
  let result = [];
  let level = { result };
  filteredContent.forEach((filter) => {
    filter.filter.name.split("/").reduce((r, name) => {
      if (!r[name]) {
        r[name] = { result: [] };
        if (filter.filter.name.endsWith(name)) {
          r.result.push({ name, children: r[name].result, filter });
        } else {
          r.result.push({ name, children: r[name].result });
        }
      }
      return r[name];
    }, level);
  });
  return result;
}
function instance8($$self, $$props, $$invalidate) {
  let $sortedFeedsStore;
  let $filteredItemsStore;
  let $settingsStore;
  component_subscribe($$self, sortedFeedsStore, ($$value) => $$invalidate(2, $sortedFeedsStore = $$value));
  component_subscribe($$self, filteredItemsStore, ($$value) => $$invalidate(3, $filteredItemsStore = $$value));
  component_subscribe($$self, settingsStore, ($$value) => $$invalidate(4, $settingsStore = $$value));
  let { plugin } = $$props;
  let folded = [];
  foldedState.subscribe((value) => {
    $$invalidate(1, folded = value);
  });
  function toggleFold(folder) {
    if (!folded) {
      $$invalidate(1, folded = []);
    }
    if (folded.contains(folder)) {
      folded.remove(folder);
    } else
      folded.push(folder);
    plugin.writeFolded(folded);
  }
  function openMenuForFolder(e, folder) {
    return __async(this, null, function* () {
      const items = [];
      for (const feed of $sortedFeedsStore[folder]) {
        for (let item of feed.items) {
          items.push(item);
        }
      }
      yield openMenu(e, items);
    });
  }
  function openMenu(e, feedItems) {
    return __async(this, null, function* () {
      const menu = new import_obsidian15.Menu(plugin.app);
      menu.addItem((menuItem) => {
        menuItem.setIcon("create-new").setTitle(t("create_all")).onClick(() => __async(this, null, function* () {
          for (const item of feedItems) {
            yield Action.CREATE_NOTE.processor(plugin, item);
          }
        }));
      });
      menu.addItem((menuItem) => {
        menuItem.setIcon("feather-eye").setTitle(t("mark_all_as_read")).onClick(() => __async(this, null, function* () {
          for (const item of feedItems) {
            item.read = true;
          }
          const items = plugin.settings.items;
          yield plugin.writeFeedContent(() => {
            return items;
          });
        }));
      });
      menu.showAtPosition({ x: e.x, y: e.y });
    });
  }
  const click_handler = () => toggleFold("rss-filters");
  const contextmenu_handler = (folder, e) => openMenu(e, folder.filter.items.items);
  const click_handler_1 = (folder) => toggleFold("rss-filters-" + folder.name);
  const click_handler_2 = (child) => toggleFold("rss-filters-" + child.filter.filter.name);
  const click_handler_3 = () => toggleFold("rss-folders");
  const click_handler_4 = (folder) => toggleFold(folder);
  const contextmenu_handler_1 = (folder, e) => openMenuForFolder(e, folder);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [
    plugin,
    folded,
    $sortedFeedsStore,
    $filteredItemsStore,
    $settingsStore,
    toggleFold,
    openMenuForFolder,
    openMenu,
    click_handler,
    contextmenu_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    contextmenu_handler_1
  ];
}
var FolderView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, { plugin: 0 });
  }
};
var FolderView_default = FolderView;

// src/view/ViewLoader.ts
var ViewLoader = class extends import_obsidian16.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getDisplayText() {
    return t("RSS_Feeds");
  }
  getViewType() {
    return VIEW_ID;
  }
  getIcon() {
    return "rss";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.feed = new FolderView_default({
        target: this.contentEl,
        props: {
          plugin: this.plugin
        }
      });
    });
  }
  onClose() {
    if (this.feed) {
      this.feed.$destroy();
    }
    return Promise.resolve();
  }
};

// src/main.ts
var import_lodash6 = __toModule(require_lodash());
var import_lodash7 = __toModule(require_lodash2());
var import_lodash8 = __toModule(require_lodash3());
var import_lodash9 = __toModule(require_lodash4());

// src/modals/FilteredFolderModal.ts
var import_obsidian17 = __toModule(require("obsidian"));
var FilterType;
(function(FilterType2) {
  FilterType2[FilterType2["UNREAD"] = 0] = "UNREAD";
  FilterType2[FilterType2["READ"] = 1] = "READ";
  FilterType2[FilterType2["FAVORITES"] = 2] = "FAVORITES";
})(FilterType || (FilterType = {}));
var SortOrder;
(function(SortOrder2) {
  SortOrder2[SortOrder2["DATE_NEWEST"] = 0] = "DATE_NEWEST";
  SortOrder2[SortOrder2["DATE_OLDEST"] = 1] = "DATE_OLDEST";
  SortOrder2[SortOrder2["ALPHABET_NORMAL"] = 2] = "ALPHABET_NORMAL";
  SortOrder2[SortOrder2["ALPHABET_INVERTED"] = 3] = "ALPHABET_INVERTED";
})(SortOrder || (SortOrder = {}));
var FilteredFolderModal = class extends BaseModal {
  constructor(plugin, folder) {
    super(plugin.app);
    this.filterTags = [];
    this.ignoreTags = [];
    this.filterFolders = [];
    this.ignoreFolders = [];
    this.filterFeeds = [];
    this.ignoreFeeds = [];
    this.saved = false;
    this.plugin = plugin;
    if (folder) {
      this.name = folder.name;
      this.sortOrder = folder.sortOrder;
      this.filterTags = folder.filterTags;
      this.ignoreTags = folder.ignoreTags;
      this.filterFolders = folder.filterFolders;
      this.ignoreFolders = folder.ignoreFolders;
      this.filterFeeds = folder.filterFeeds;
      this.ignoreFeeds = folder.ignoreFeeds;
      this.read = folder.read;
      this.unread = folder.unread;
      this.favorites = folder.favorites;
    }
  }
  display() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      let nameText;
      const name = new import_obsidian17.Setting(contentEl).setName(t("name")).setDesc(t("filter_name_help")).addText((text2) => {
        nameText = text2;
        text2.setValue(this.name).onChange((value) => {
          this.removeValidationError(text2);
          this.name = value;
        });
      });
      name.controlEl.addClass("rss-setting-input");
      new import_obsidian17.Setting(contentEl).setName(t("only_favorites")).addToggle((toggle) => {
        toggle.setValue(this.favorites).onChange((value) => {
          this.favorites = value;
        });
      });
      new import_obsidian17.Setting(contentEl).setName(t("show_read")).addToggle((toggle) => {
        toggle.setValue(this.read).onChange((value) => {
          this.read = value;
        });
      });
      new import_obsidian17.Setting(contentEl).setName(t("show_unread")).addToggle((toggle) => {
        toggle.setValue(this.unread).onChange((value) => {
          this.unread = value;
        });
      });
      const sorting = new import_obsidian17.Setting(contentEl).setName(t("sort")).addDropdown((dropdown) => {
        for (const order2 in SortOrder) {
          if (order2.length > 1) {
            dropdown.addOption(order2, t("sort_" + order2.toLowerCase()));
          }
        }
        dropdown.setValue(this.sortOrder).onChange((value) => __async(this, null, function* () {
          this.sortOrder = value;
        }));
      });
      sorting.controlEl.addClass("rss-setting-input");
      const foldersDiv = contentEl.createDiv("folders");
      foldersDiv.createEl("h2", { text: t("folders") });
      foldersDiv.createEl("p", { text: t("filter_folder_help") });
      for (const folder in this.filterFolders) {
        new import_obsidian17.Setting(foldersDiv).addSearch((search) => __async(this, null, function* () {
          new ArraySuggest(this.app, search.inputEl, get_store_value(folderStore));
          search.setValue(this.filterFolders[folder]).onChange((value) => __async(this, null, function* () {
            this.removeValidationError(search);
            this.filterFolders = this.filterFolders.filter((e) => e !== this.filterFolders[folder]);
            this.filterFolders.push(value);
          }));
        })).addExtraButton((button) => {
          button.setTooltip(t("delete")).setIcon("trash").onClick(() => {
            this.filterFolders = this.filterFolders.filter((e) => e !== this.filterFolders[folder]);
            this.display();
          });
        });
      }
      let folderValue = "";
      const newFolder = new import_obsidian17.Setting(foldersDiv).addSearch((search) => __async(this, null, function* () {
        new ArraySuggest(this.app, search.inputEl, get_store_value(folderStore));
        search.onChange((value) => __async(this, null, function* () {
          folderValue = value;
        }));
      })).addExtraButton((button) => {
        button.setTooltip(t("add")).setIcon("plus").onClick(() => {
          this.filterFolders.push(folderValue);
          this.display();
        });
      });
      newFolder.controlEl.addClass("rss-setting-input");
      foldersDiv.createEl("p", { text: t("filter_folder_ignore_help") });
      for (const folder in this.ignoreFolders) {
        new import_obsidian17.Setting(foldersDiv).addSearch((search) => __async(this, null, function* () {
          new ArraySuggest(this.app, search.inputEl, get_store_value(folderStore));
          search.setValue(this.ignoreFolders[folder]).onChange((value) => __async(this, null, function* () {
            this.removeValidationError(search);
            this.ignoreFolders = this.ignoreFolders.filter((e) => e !== this.ignoreFolders[folder]);
            this.ignoreFolders.push(value);
          }));
        })).addExtraButton((button) => {
          button.setTooltip(t("delete")).setIcon("trash").onClick(() => {
            this.ignoreFolders = this.ignoreFolders.filter((e) => e !== this.ignoreFolders[folder]);
            this.display();
          });
        });
      }
      let folderIgnoreValue = "";
      const newIgnoreFolder = new import_obsidian17.Setting(foldersDiv).addSearch((search) => __async(this, null, function* () {
        new ArraySuggest(this.app, search.inputEl, get_store_value(folderStore));
        search.onChange((value) => __async(this, null, function* () {
          folderIgnoreValue = value;
        }));
      })).addExtraButton((button) => {
        button.setTooltip(t("add")).setIcon("plus").onClick(() => {
          this.ignoreFolders.push(folderIgnoreValue);
          this.display();
        });
      });
      newIgnoreFolder.controlEl.addClass("rss-setting-input");
      const feedsDiv = contentEl.createDiv("feeds");
      feedsDiv.createEl("h2", { text: t("feeds") });
      feedsDiv.createEl("p", { text: t("filter_feed_help") });
      const feeds = this.plugin.settings.feeds.filter((feed) => {
        if (this.filterFolders.length === 0)
          return true;
        return this.filterFolders.contains(feed.folder);
      }).map((feed) => feed.name);
      for (const feed in this.filterFeeds) {
        new import_obsidian17.Setting(feedsDiv).addText((text2) => {
          text2.setDisabled(true).setValue(this.filterFeeds[feed]);
        }).addExtraButton((button) => {
          button.setTooltip(t("delete")).setIcon("trash").onClick(() => {
            this.filterFeeds = this.filterFeeds.filter((e) => e !== this.filterFeeds[feed]);
            this.display();
          });
        });
      }
      let feedValue = "";
      const newFeed = new import_obsidian17.Setting(feedsDiv).addSearch((search) => __async(this, null, function* () {
        new ArraySuggest(this.app, search.inputEl, new Set(feeds));
        search.onChange((value) => __async(this, null, function* () {
          const feeds2 = this.plugin.settings.feeds.filter((feed) => feed.name === feedIgnoreValue).length;
          if (feeds2 !== 1) {
            this.setValidationError(search, t("no_feed_with_name"));
            return;
          }
          feedValue = value;
        }));
      })).addExtraButton((button) => {
        button.setTooltip(t("add")).setIcon("plus").onClick(() => {
          const feeds2 = this.plugin.settings.feeds.filter((feed) => feed.name === feedIgnoreValue).length;
          if (feeds2 !== 1)
            return;
          this.filterFeeds.push(feedValue);
          this.display();
        });
      });
      newFeed.controlEl.addClass("rss-setting-input");
      feedsDiv.createEl("p", { text: t("filter_feed_ignore_help") });
      for (const feed in this.ignoreFeeds) {
        new import_obsidian17.Setting(feedsDiv).addText((text2) => {
          text2.setDisabled(true).setValue(this.ignoreFeeds[feed]);
        }).addExtraButton((button) => {
          button.setTooltip(t("delete")).setIcon("trash").onClick(() => {
            this.ignoreFeeds = this.ignoreFeeds.filter((e) => e !== this.ignoreFeeds[feed]);
            this.display();
          });
        });
      }
      let feedIgnoreValue = "";
      const newIgnoreFeed = new import_obsidian17.Setting(feedsDiv).addSearch((search) => __async(this, null, function* () {
        new ArraySuggest(this.app, search.inputEl, new Set(feeds));
        search.onChange((value) => __async(this, null, function* () {
          const feeds2 = this.plugin.settings.feeds.filter((feed) => feed.name === feedIgnoreValue).length;
          if (feeds2 !== 1) {
            this.setValidationError(search, t("no_feed_with_name"));
            return;
          }
          feedIgnoreValue = value;
        }));
      })).addExtraButton((button) => {
        button.setTooltip(t("add")).setIcon("plus").onClick(() => {
          const feeds2 = this.plugin.settings.feeds.filter((feed) => feed.name === feedIgnoreValue).length;
          if (feeds2 !== 1)
            return;
          this.ignoreFeeds.push(feedIgnoreValue);
          this.display();
        });
      });
      newIgnoreFeed.controlEl.addClass("rss-setting-input");
      const tagDiv = contentEl.createDiv("tags");
      tagDiv.createEl("h2", { text: t("tags") });
      tagDiv.createEl("p", { text: t("filter_tags_help") });
      for (const tag in this.filterTags) {
        new import_obsidian17.Setting(tagDiv).addText((text2) => {
          text2.setDisabled(true).setValue(this.filterTags[tag]);
        }).addExtraButton((button) => {
          button.setTooltip(t("delete")).setIcon("trash").onClick(() => {
            this.filterTags = this.filterTags.filter((e) => e !== this.filterTags[tag]);
            this.display();
          });
        });
      }
      let tagValue = "";
      let tagComponent;
      const newTag = new import_obsidian17.Setting(tagDiv).addSearch((search) => __async(this, null, function* () {
        tagComponent = search;
        new ArraySuggest(this.app, search.inputEl, get_store_value(tagsStore));
        search.onChange((value) => __async(this, null, function* () {
          if (!value.match(TAG_REGEX) || value.match(NUMBER_REGEX) || value.contains(" ") || value.contains("#")) {
            this.setValidationError(search, t("invalid_tag"));
            return;
          }
          tagValue = value;
        }));
      })).addExtraButton((button) => {
        button.setTooltip(t("add")).setIcon("plus").onClick(() => {
          if (!tagValue.match(TAG_REGEX) || tagValue.match(NUMBER_REGEX) || tagValue.contains(" ") || tagValue.contains("#")) {
            this.setValidationError(tagComponent, t("invalid_tag"));
            return;
          }
          this.filterTags.push(tagValue);
          this.display();
        });
      });
      newTag.controlEl.addClass("rss-setting-input");
      tagDiv.createEl("p", { text: t("filter_tags_ignore_help") });
      for (const tag in this.ignoreTags) {
        new import_obsidian17.Setting(tagDiv).addSearch((search) => __async(this, null, function* () {
          new ArraySuggest(this.app, search.inputEl, get_store_value(tagsStore));
          search.setValue(this.ignoreTags[tag]).onChange((value) => __async(this, null, function* () {
            this.removeValidationError(search);
            if (!value.match(TAG_REGEX) || value.match(NUMBER_REGEX) || value.contains(" ") || value.contains("#")) {
              this.setValidationError(search, t("invalid_tag"));
              return;
            }
            this.ignoreTags = this.ignoreTags.filter((e) => e !== this.ignoreTags[tag]);
            this.ignoreTags.push(value);
          }));
        })).addExtraButton((button) => {
          button.setTooltip(t("delete")).setIcon("trash").onClick(() => {
            this.ignoreTags = this.ignoreTags.filter((e) => e !== this.ignoreTags[tag]);
            this.display();
          });
        });
      }
      let ignoreTagValue = "";
      let ignoreTagComponent;
      const newTagIgnore = new import_obsidian17.Setting(tagDiv).addSearch((search) => __async(this, null, function* () {
        ignoreTagComponent = search;
        new ArraySuggest(this.app, search.inputEl, get_store_value(tagsStore));
        search.onChange((value) => __async(this, null, function* () {
          if (!value.match(TAG_REGEX) || value.match(NUMBER_REGEX) || value.contains(" ") || value.contains("#")) {
            this.setValidationError(search, t("invalid_tag"));
            return;
          }
          ignoreTagValue = value;
        }));
      })).addExtraButton((button) => {
        button.setTooltip(t("add")).setIcon("plus").onClick(() => {
          if (!ignoreTagValue.match(TAG_REGEX) || ignoreTagValue.match(NUMBER_REGEX) || ignoreTagValue.contains(" ") || ignoreTagValue.contains("#")) {
            this.setValidationError(ignoreTagComponent, t("invalid_tag"));
            return;
          }
          this.ignoreTags.push(ignoreTagValue);
          this.display();
        });
      });
      newTagIgnore.controlEl.addClass("rss-setting-input");
      const footerEl = contentEl.createDiv();
      const footerButtons = new import_obsidian17.Setting(footerEl);
      footerButtons.addButton((b) => {
        b.setTooltip(t("save")).setIcon("checkmark").onClick(() => __async(this, null, function* () {
          let error = false;
          if (!nameText.getValue().length) {
            this.setValidationError(nameText, t("invalid_name"));
            error = true;
          }
          if (error) {
            new import_obsidian17.Notice(t("fix_errors"));
            return;
          }
          this.saved = true;
          this.close();
        }));
        return b;
      });
      footerButtons.addExtraButton((b) => {
        b.setIcon("cross").setTooltip(t("cancel")).onClick(() => {
          this.saved = false;
          this.close();
        });
        return b;
      });
    });
  }
  onOpen() {
    return __async(this, null, function* () {
      yield this.display();
    });
  }
};

// src/main.ts
var import_ts_md53 = __toModule(require_md5());

// src/settings/SettingsTab.ts
var import_obsidian26 = __toModule(require("obsidian"));

// src/settings/FolderSuggestor.ts
var import_obsidian18 = __toModule(require("obsidian"));
var FolderSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian18.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/FeedSettings.ts
var import_lodash4 = __toModule(require_lodash5());
var import_lodash5 = __toModule(require_lodash());
var import_obsidian23 = __toModule(require("obsidian"));

// src/modals/FeedModal.ts
var import_obsidian19 = __toModule(require("obsidian"));

// src/view/FeedFolderSuggest.ts
var FeedFolderSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const folders = get_store_value(folderStore);
    const lowerCaseInputStr = inputStr.toLowerCase();
    return [...folders].filter((folder) => folder.contains(lowerCaseInputStr));
  }
  renderSuggestion(folder, el) {
    el.setText(folder);
  }
  selectSuggestion(folder) {
    this.inputEl.value = folder;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/modals/FeedModal.ts
var FeedModal = class extends BaseModal {
  constructor(plugin, feed) {
    super(plugin.app);
    this.saved = false;
    if (feed) {
      this.name = feed.name;
      this.url = feed.url;
      this.folder = feed.folder;
    }
  }
  display() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      let nameText;
      const name = new import_obsidian19.Setting(contentEl).setName(t("name")).setDesc(t("name_help")).addText((text2) => {
        nameText = text2;
        text2.setValue(this.name).onChange((value) => {
          this.removeValidationError(text2);
          this.name = value;
        });
      });
      name.controlEl.addClass("rss-setting-input");
      let urlText;
      const url = new import_obsidian19.Setting(contentEl).setName("URL").setDesc(t("url_help")).addText((text2) => {
        urlText = text2;
        text2.setValue(this.url).onChange((value) => __async(this, null, function* () {
          this.removeValidationError(text2);
          this.url = value;
        }));
      });
      url.controlEl.addClass("rss-setting-input");
      new import_obsidian19.Setting(contentEl).setName(t("folder")).setDesc(t("folder_help")).addSearch((search) => __async(this, null, function* () {
        new FeedFolderSuggest(this.app, search.inputEl);
        search.setValue(this.folder).setPlaceholder(t("no_folder")).onChange((value) => __async(this, null, function* () {
          this.folder = value;
        }));
      }));
      const footerEl = contentEl.createDiv();
      const footerButtons = new import_obsidian19.Setting(footerEl);
      footerButtons.addButton((b) => {
        b.setTooltip(t("save")).setIcon("checkmark").onClick(() => __async(this, null, function* () {
          let error = false;
          if (!nameText.getValue().length) {
            this.setValidationError(nameText, t("invalid_name"));
            error = true;
          }
          if (!urlText.getValue().length) {
            this.setValidationError(urlText, t("invalid_url"));
            error = true;
          }
          if (!isValidHttpUrl(urlText.getValue())) {
            this.setValidationError(urlText, t("invalid_url"));
            error = true;
          } else {
            const items = yield getFeedItems({ name: "test", url: urlText.getValue(), folder: "" });
            if (items.items.length == 0) {
              this.setValidationError(urlText, t("invalid_feed"));
              error = true;
            }
          }
          if (error) {
            new import_obsidian19.Notice(t("fix_errors"));
            return;
          }
          this.saved = true;
          this.close();
        }));
        return b;
      });
      footerButtons.addExtraButton((b) => {
        b.setIcon("cross").setTooltip(t("cancel")).onClick(() => {
          this.saved = false;
          this.close();
        });
        return b;
      });
    });
  }
  onOpen() {
    return __async(this, null, function* () {
      yield this.display();
    });
  }
};

// src/modals/ImportModal.ts
var import_obsidian20 = __toModule(require("obsidian"));

// src/parser/opmlParser.ts
function loadFeedsFromString(importData, defaultFolder) {
  return __async(this, null, function* () {
    const rawData = new window.DOMParser().parseFromString(importData, "text/xml");
    const feeds = [];
    const outlines = rawData.getElementsByTagName("outline");
    for (let i = 0, max2 = outlines.length; i < max2; i++) {
      const current = outlines[i];
      if (!current.hasChildNodes()) {
        const title = current.getAttribute("title");
        const xmlUrl = current.getAttribute("xmlUrl");
        if (current.parentElement.hasAttribute("title")) {
          feeds.push({
            name: title,
            url: xmlUrl,
            folder: defaultFolder + (defaultFolder ? "/" : "") + current.parentElement.getAttribute("title")
          });
        } else {
          feeds.push({
            name: title,
            url: xmlUrl,
            folder: defaultFolder + ""
          });
        }
      }
    }
    return feeds;
  });
}

// src/modals/ImportModal.ts
var ImportModal = class extends import_obsidian20.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.importData = "";
    this.defaultFolder = "";
    this.plugin = plugin;
  }
  onOpen() {
    return __async(this, null, function* () {
      const setting = new import_obsidian20.Setting(this.contentEl).setName(t("choose_file")).setDesc(t("choose_file_help"));
      const input = setting.controlEl.createEl("input", {
        attr: {
          type: "file",
          accept: ".xml,.opml"
        }
      });
      input.onchange = () => __async(this, null, function* () {
        const { files } = input;
        if (!files.length)
          return;
        for (const id in files) {
          const file = files[id];
          const reader = new FileReader();
          reader.onload = () => {
            this.importData = reader.result;
          };
          reader.readAsText(file);
        }
      });
      new import_obsidian20.Setting(this.contentEl).setName(t("base_folder")).addSearch((search) => {
        new FeedFolderSuggest(this.app, search.inputEl);
        search.setValue(this.defaultFolder).onChange((value) => {
          this.defaultFolder = value;
        });
      });
      new import_obsidian20.Setting(this.contentEl).addButton((button) => {
        button.setIcon("import-glyph").setTooltip(t("import")).onClick(() => __async(this, null, function* () {
          if (this.importData) {
            const feeds = yield loadFeedsFromString(this.importData, this.defaultFolder);
            yield this.plugin.writeFeeds(() => this.plugin.settings.feeds.concat(feeds));
            new import_obsidian20.Notice(t("imported_x_feeds", String(feeds.length)));
            this.close();
          } else {
            new import_obsidian20.Notice(t("fix_errors"));
          }
        }));
      }).addExtraButton((button) => {
        button.setIcon("cross").setTooltip(t("cancel")).onClick(() => {
          this.close();
        });
      });
    });
  }
};

// src/settings/FeedSettings.ts
var import_ts_md52 = __toModule(require_md5());

// src/modals/CleanupModal.ts
var import_obsidian21 = __toModule(require("obsidian"));
var import_lodash = __toModule(require_lodash5());
var import_lodash2 = __toModule(require_lodash());
var CleanupModal = class extends BaseModal {
  constructor(plugin) {
    super(plugin.app);
    this.tag = "";
    this.feed = "wallabag.xml-option-id";
    this.plugin = plugin;
  }
  onOpen() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      contentEl.createEl("h1", { text: t("cleanup") });
      contentEl.createEl("p", { text: t("cleanup_help") });
      contentEl.createEl("p", { text: t("cleanup_help2") });
      new import_obsidian21.Setting(contentEl).setName(t("unread")).addToggle((toggle) => {
        toggle.onChange((value) => {
          this.unread = value;
        });
      });
      new import_obsidian21.Setting(contentEl).setName(t("read")).addToggle((toggle) => {
        toggle.onChange((value) => {
          this.read = value;
        });
      });
      new import_obsidian21.Setting(contentEl).setName(t("favorite")).addToggle((toggle) => {
        toggle.onChange((value) => {
          this.favorite = value;
        });
      });
      new import_obsidian21.Setting(contentEl).setName(t("tag")).addSearch((search) => {
        const tags = [];
        for (const feed of this.plugin.settings.items) {
          for (const item of feed.items) {
            if (item !== void 0)
              tags.push(...item.tags);
          }
        }
        new ArraySuggest(this.app, search.inputEl, new Set(tags));
        search.onChange((value) => __async(this, null, function* () {
          this.tag = value;
        }));
      });
      let older_than_setting;
      new import_obsidian21.Setting(contentEl).setName(t("older_than")).setDesc(t("older_than_help")).addText((text2) => {
        older_than_setting = text2;
        text2.setPlaceholder("5").onChange((value) => {
          this.removeValidationError(text2);
          if (Number(value)) {
            this.older_than = Number(value);
          }
        });
      }).controlEl.addClass("rss-setting-input");
      older_than_setting.inputEl.setAttr("onkeypress", "return event.charCode >= 48 && event.charCode <= 57");
      new import_obsidian21.Setting(contentEl).setName(t("from_feed")).addDropdown((dropdown) => {
        dropdown.addOption("wallabag.xml-option-id", t("all"));
        const sorted = (0, import_lodash.default)((0, import_lodash2.default)(this.plugin.settings.feeds, "folder"), function(o) {
          return o[0].folder;
        });
        for (const [, feeds] of Object.entries(sorted)) {
          for (const id in feeds) {
            const feed = feeds[id];
            dropdown.addOption(feed.folder + "-" + feed.name, feed.folder + " - " + feed.name);
          }
          dropdown.setValue(this.feed);
        }
        dropdown.onChange((value) => {
          this.feed = value;
        });
      });
      const details = contentEl.createEl("details");
      const summary = details.createEl("summary");
      summary.setText(t("advanced"));
      const advanced = details.createDiv("advanced");
      new import_obsidian21.Setting(advanced).setName(t("remove_wrong_feed")).setDesc(t("remove_wrong_feed_help")).addToggle((toggle) => {
        toggle.onChange((value) => {
          this.wrong_feed = value;
        });
      });
      new import_obsidian21.Setting(contentEl).addButton((button) => {
        button.setIcon("feather-trash").setTooltip(t("perform_cleanup")).onClick(() => __async(this, null, function* () {
          let items = this.plugin.settings.items;
          let date = (0, import_obsidian21.moment)();
          if (this.older_than) {
            date = (0, import_obsidian21.moment)().subtract(this.older_than, "days");
          }
          let count = 0;
          const itemsCount = items.reduce((count2, current) => count2 + current.items.length, 0);
          const notice = new import_obsidian21.Notice(t("scanning_items", "0", itemsCount.toString()));
          for (const feed of items) {
            for (const item of feed.items) {
              if (item !== void 0) {
                let toRemove = 0;
                if (item.pubDate === void 0 || (0, import_obsidian21.moment)(item.pubDate).isBefore(date)) {
                  if (this.feed === "wallabag.xml-option-id" || this.feed === item.folder + "-" + item.feed) {
                    if (this.read && item.read || !this.read && !item.read || this.read && !item.read) {
                      toRemove++;
                    }
                    if (this.unread && !item.read || !this.unread && item.read) {
                      toRemove++;
                    }
                    if (this.favorite && item.favorite || !this.favorite && !item.favorite || this.favorite && !item.favorite) {
                      toRemove++;
                    }
                    if (this.tag === "" || item.tags.includes(this.tag)) {
                      toRemove++;
                    }
                  }
                }
                if (toRemove == 4) {
                  feed.items = feed.items.filter((value) => value.hash !== item.hash);
                }
              }
              count++;
              notice.setMessage(t("scanning_items", count.toString(), itemsCount.toString()));
            }
          }
          if (this.wrong_feed) {
            console.log("removing invalid feeds");
            const feeds = this.plugin.settings.feeds.map((feed) => {
              return feed.name;
            });
            items = items.filter((item) => {
              return feeds.includes(item.name);
            });
            const folders = get_store_value(folderStore);
            items = items.filter((item) => {
              return folders.has(item.folder);
            });
            items.forEach((feed) => {
              feed.items = feed.items.filter((item) => {
                return feed.name === item.feed && feed.folder === item.folder;
              });
            });
          }
          yield this.plugin.writeFeedContent(() => {
            return items;
          });
          this.close();
        }));
      }).addExtraButton((button) => {
        button.setIcon("cross").setTooltip(t("cancel")).onClick(() => {
          this.close();
        });
      });
    });
  }
};

// src/parser/opmlExport.ts
var import_lodash3 = __toModule(require_lodash());
function generateOPML(feeds) {
  const doc = document.implementation.createDocument("", "opml");
  const head = doc.createElement("head");
  const title = doc.createElement("title");
  head.appendChild(title);
  title.setText("Obsidian RSS Export");
  doc.documentElement.appendChild(head);
  const body = doc.createElement("body");
  doc.documentElement.appendChild(body);
  const sorted = (0, import_lodash3.default)(feeds, "folder");
  for (const id of Object.keys(sorted)) {
    const folder = sorted[id];
    const outline = doc.createElement("outline");
    body.appendChild(outline);
    outline.setAttribute("title", folder[0].folder);
    for (const feed of folder) {
      const exportFeed = doc.createElement("outline");
      exportFeed.setAttribute("title", feed.name);
      exportFeed.setAttribute("xmlUrl", feed.url);
      outline.append(exportFeed);
    }
  }
  return new XMLSerializer().serializeToString(doc.documentElement);
}

// src/modals/MessageModal.ts
var import_obsidian22 = __toModule(require("obsidian"));
var MessageModal = class extends import_obsidian22.Modal {
  constructor(plugin, message) {
    super(plugin.app);
    this.message = message;
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h1", { text: this.message });
    contentEl.createEl("p", { text: t("do_not_close") });
  }
  setMessage(message) {
    this.message = message;
    this.display();
  }
};

// src/settings/FeedSettings.ts
function displayFeedSettings(plugin, container) {
  container.empty();
  container.createEl("h3", { text: t("feeds") });
  new import_obsidian23.Setting(container).setName(t("add_new")).setDesc(t("add_new_feed")).addButton((button) => {
    return button.setTooltip(t("add_new_feed")).setIcon("plus").onClick(() => __async(this, null, function* () {
      const modal = new FeedModal(plugin);
      modal.onClose = () => __async(this, null, function* () {
        if (modal.saved) {
          if (plugin.settings.feeds.some((item) => item.url === modal.url)) {
            new import_obsidian23.Notice(t("feed_already_configured"));
            return;
          }
          yield plugin.writeFeeds(() => plugin.settings.feeds.concat({
            name: modal.name,
            url: modal.url,
            folder: modal.folder ? modal.folder : ""
          }));
          displayFeedSettings(plugin, container);
        }
      });
      modal.open();
    }));
  }).addExtraButton((button) => __async(this, null, function* () {
    button.setTooltip(t("import_opml")).setIcon("download").onClick(() => {
      const modal = new ImportModal(plugin);
      modal.onClose = () => {
        displayFeedSettings(plugin, container);
      };
      modal.open();
    });
  })).addExtraButton((button) => __async(this, null, function* () {
    button.setTooltip(t("export_opml")).setIcon("upload").onClick(() => {
      if (plugin.app.vault.adapter.exists("rss-feeds-export.opml")) {
        plugin.app.vault.adapter.remove("rss-feeds-export.opml");
      }
      plugin.app.vault.create("rss-feeds-export.opml", generateOPML(plugin.settings.feeds));
      new import_obsidian23.Notice(t("created_export"));
    });
  })).addExtraButton((button) => __async(this, null, function* () {
    button.setTooltip(t("perform_cleanup")).setIcon("lucide-trash").onClick(() => {
      new CleanupModal(plugin).open();
    });
  }));
  const feedsDiv = container.createDiv("feeds");
  displayFeedList(plugin, feedsDiv);
}
function displayFeedList(plugin, container, disabled = false) {
  container.empty();
  const sorted = (0, import_lodash4.default)((0, import_lodash5.default)(plugin.settings.feeds, "folder"), function(o) {
    return o[0].folder;
  });
  for (const [, feeds] of Object.entries(sorted)) {
    for (const id in feeds) {
      const feed = feeds[id];
      const setting = new import_obsidian23.Setting(container);
      setting.setName((feed.folder ? feed.folder : t("no_folder")) + " - " + feed.name);
      setting.setDesc(feed.url);
      setting.addExtraButton((b) => {
        b.setDisabled(disabled).setIcon("edit").setTooltip(t("edit")).onClick(() => {
          const modal = new FeedModal(plugin, feed);
          const oldFeed = feed;
          modal.onClose = () => __async(this, null, function* () {
            if (modal.saved) {
              const feeds2 = plugin.settings.feeds;
              feeds2.remove(oldFeed);
              feeds2.push({
                name: modal.name,
                url: modal.url,
                folder: modal.folder ? modal.folder : ""
              });
              let items = plugin.settings.items;
              items = items.filter((content) => {
                return content.name === oldFeed.name && content.folder === oldFeed.folder;
              });
              items.forEach((content) => {
                content.name = modal.name;
                content.folder = modal.folder;
                content.hash = new import_ts_md52.Md5().appendStr(modal.name).appendStr(modal.folder).end();
                content.items.forEach((item) => {
                  item.feed = modal.name;
                  item.folder = modal.folder ? modal.folder : "";
                  item.hash = new import_ts_md52.Md5().appendStr(item.title).appendStr(item.folder).appendStr(item.link).end();
                });
              });
              yield plugin.writeFeedContent(() => {
                return items;
              });
              yield plugin.writeFeeds(() => feeds2);
              displayFeedList(plugin, container);
            }
          });
          modal.open();
        });
      }).addExtraButton((button) => {
        button.setDisabled(disabled).setTooltip(t("from_archive")).setIcon("archive").onClick(() => __async(this, null, function* () {
          const modal = new MessageModal(plugin, t("reading_archive"));
          modal.open();
          displayFeedList(plugin, container, true);
          const timemap = yield (0, import_obsidian23.request)({
            method: "GET",
            url: "https://web.archive.org/web/timemap/link/" + feed.url
          });
          const items = [];
          const lines = timemap.split("\n");
          for (const line of lines) {
            if (line.contains("memento")) {
              const link = line.slice(1, line.indexOf(">"));
              const first = link.substring(0, 41);
              const second = link.substring(42);
              items.push(yield getFeedItems({
                name: feed.name,
                url: first + "id_" + second,
                folder: feed.folder
              }));
            }
          }
          modal.setMessage(t("scanning_duplicates"));
          for (const feed2 of plugin.settings.items) {
            for (const content of items) {
              if (feed2.folder === content.folder && feed2.name === content.name) {
                const sortedItems = content.items.sort((a, b) => {
                  return (0, import_obsidian23.moment)(b.pubDate).diff((0, import_obsidian23.moment)(a.pubDate));
                });
                for (const item of sortedItems) {
                  const filter = feed2.items.filter((filterItem) => {
                    return filterItem.folder === item.folder && filterItem.title === item.title;
                  });
                  if (filter.length === 0) {
                    feed2.items.push(item);
                  }
                }
              }
            }
          }
          yield plugin.writeFeedContent(() => {
            return plugin.settings.items;
          });
          displayFeedList(plugin, container, false);
          modal.setMessage(t("refreshed_feeds"));
          modal.close();
        }));
      }).addExtraButton((b) => {
        b.setDisabled(disabled).setIcon("lucide-trash").setTooltip(t("delete")).onClick(() => __async(this, null, function* () {
          const feeds2 = plugin.settings.feeds;
          feeds2.remove(feed);
          yield plugin.writeFeeds(() => feeds2);
          let content = plugin.settings.items;
          content = content.filter((content2) => {
            return content2.name !== feed.name;
          });
          yield plugin.writeFeedContent(() => content);
          displayFeedList(plugin, container);
        }));
      });
    }
  }
}

// src/settings/HotkeySettings.ts
var import_obsidian24 = __toModule(require("obsidian"));
function displayHotkeys(plugin, containerEl) {
  containerEl.empty();
  containerEl.createEl("h2", { text: t("hotkeys") });
  containerEl.createEl("h3", { text: t("hotkeys_reading") });
  new import_obsidian24.Setting(containerEl).setName(t("create_note")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.create).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
            create: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  new import_obsidian24.Setting(containerEl).setName(t("paste_to_note")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.paste).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
            paste: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  new import_obsidian24.Setting(containerEl).setName(t("open_browser")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.open).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
            open: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  new import_obsidian24.Setting(containerEl).setName(t("copy_to_clipboard")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.copy).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
            copy: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  new import_obsidian24.Setting(containerEl).setName(t("mark_as_favorite_remove")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.favorite).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
            favorite: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  new import_obsidian24.Setting(containerEl).setName(t("mark_as_read_unread")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.read).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, this.plugin.settings.hotkeys), {
            read: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  new import_obsidian24.Setting(containerEl).setName(t("edit_tags")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.tags).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
            tags: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  new import_obsidian24.Setting(containerEl).setName(t("next")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.next).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
            next: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  new import_obsidian24.Setting(containerEl).setName(t("previous")).addButton((button) => {
    button.setButtonText(plugin.settings.hotkeys.previous).setTooltip(t("customize_hotkey")).onClick(() => {
      button.setButtonText(t("press_key"));
      const listener = (e) => __async(this, null, function* () {
        window.removeEventListener("keyup", listener);
        yield plugin.writeSettings(() => ({
          hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
            previous: e.key
          })
        }));
        displayHotkeys(plugin, containerEl);
      });
      window.addEventListener("keyup", listener);
    });
  });
  if (plugin.app.plugins.plugins["obsidian-tts"]) {
    new import_obsidian24.Setting(containerEl).setName(t("read_article_tts")).setTooltip(t("customize_hotkey")).addButton((button) => {
      button.setButtonText(plugin.settings.hotkeys.tts).onClick(() => {
        button.setButtonText(t("press_key"));
        const listener = (e) => __async(this, null, function* () {
          window.removeEventListener("keyup", listener);
          yield plugin.writeSettings(() => ({
            hotkeys: __spreadProps(__spreadValues({}, plugin.settings.hotkeys), {
              tts: e.key
            })
          }));
          displayHotkeys(plugin, containerEl);
        });
        window.addEventListener("keyup", listener);
      });
    });
  }
}

// src/settings/FilterSettings.ts
var import_obsidian25 = __toModule(require("obsidian"));
function displayFilterSettings(plugin, containerEl) {
  containerEl.empty();
  containerEl.createEl("hr", { attr: { style: "border-top: 5px solid var(--background-modifier-border);" } });
  containerEl.createEl("h3", { text: t("filtered_folders") });
  new import_obsidian25.Setting(containerEl).setName(t("add_new")).setDesc(t("add_new_filter")).addButton((button) => {
    return button.setTooltip(t("add_new_filter")).setIcon("plus").onClick(() => __async(this, null, function* () {
      const modal = new FilteredFolderModal(plugin);
      modal.onClose = () => __async(this, null, function* () {
        if (modal.saved) {
          if (plugin.settings.filtered.some((folder) => folder.name === modal.name)) {
            new import_obsidian25.Notice(t("filter_exists"));
            return;
          }
          yield plugin.writeFiltered(() => plugin.settings.filtered.concat({
            name: modal.name,
            sortOrder: modal.sortOrder,
            filterFeeds: modal.filterFeeds,
            filterFolders: modal.filterFolders,
            filterTags: modal.filterTags,
            favorites: modal.favorites,
            ignoreFolders: modal.ignoreFolders,
            ignoreFeeds: modal.ignoreFeeds,
            ignoreTags: modal.ignoreTags,
            read: modal.read,
            unread: modal.unread
          }));
          displayFilterSettings(plugin, containerEl);
        }
      });
      modal.open();
    }));
  });
  const filterContainer = containerEl.createDiv("filter-container");
  const filtersDiv = filterContainer.createDiv("filters");
  for (const id in plugin.settings.filtered.sort((a, b) => a.name.localeCompare(b.name))) {
    const filter = plugin.settings.filtered[id];
    if (filter === void 0) {
      continue;
    }
    const setting = new import_obsidian25.Setting(filtersDiv);
    setting.setName(filter.name);
    const description = [];
    if (filter.read)
      description.push(t("read"));
    if (filter.unread)
      description.push(t("unread"));
    if (filter.favorites)
      description.push(t("favorites"));
    let message = "";
    if (filter.filterFolders !== void 0 && filter.filterFolders.length > 0) {
      const folders = filter.filterFolders.join(",");
      message += "; " + t("from_folders") + folders;
    }
    if (filter.filterFeeds !== void 0 && filter.filterFeeds.length > 0) {
      const feeds = filter.filterFeeds.join(",");
      message += "; " + t("from_feeds") + feeds;
    }
    if (filter.filterTags !== void 0 && filter.filterTags.length > 0) {
      const tags = filter.filterTags.join(",");
      message += "; " + t("with_tags") + tags;
    }
    setting.setDesc(description.join(",") + message);
    setting.addExtraButton((b) => {
      b.setIcon("edit").setTooltip(t("edit")).onClick(() => {
        const modal = new FilteredFolderModal(plugin, filter);
        const oldFilter = filter;
        modal.onClose = () => __async(this, null, function* () {
          if (modal.saved) {
            const filters = plugin.settings.filtered;
            filters.remove(oldFilter);
            filters.push({
              name: modal.name,
              sortOrder: modal.sortOrder,
              filterFeeds: modal.filterFeeds,
              filterFolders: modal.filterFolders,
              filterTags: modal.filterTags,
              ignoreFolders: modal.ignoreFolders,
              ignoreFeeds: modal.ignoreFeeds,
              ignoreTags: modal.ignoreTags,
              favorites: modal.favorites,
              read: modal.read,
              unread: modal.unread
            });
            yield plugin.writeFiltered(() => filters);
            displayFilterSettings(plugin, containerEl);
          }
        });
        modal.open();
      });
    }).addExtraButton((b) => {
      b.setIcon("lucide-trash").setTooltip(t("delete")).onClick(() => __async(this, null, function* () {
        const filters = plugin.settings.filtered;
        filters.remove(filter);
        yield plugin.writeFiltered(() => filters);
        displayFilterSettings(plugin, containerEl);
      }));
    });
  }
}

// src/settings/SettingsTab.ts
var RSSReaderSettingsTab = class extends import_obsidian26.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: t("RSS_Reader") + " " + t("settings") });
    containerEl.createEl("h3", { text: t("file_creation") });
    const templateDesc = new DocumentFragment();
    templateDesc.createDiv().innerHTML = t("template_new_help") + "<br>" + t("available_variables") + `<br><strong>{{title}}</strong> \u2192 ${t("article_title")}<br><strong>{{link}}</strong> \u2192 ${t("article_link")}<br><strong>{{author}}</strong> \u2192 ${t("article_author")}<br><strong>{{published}}</strong> \u2192 ${t("article_published")}<br><strong>{{created}}</strong> \u2192 ${t("note_created")}<br><strong>{{description}}</strong> \u2192 ${t("article_description")}<br><strong>{{content}}</strong> \u2192 ${t("article_content")}<br><strong>{{folder}}</strong> \u2192 ${t("feed_folder")}<br><strong>{{feed}}</strong> \u2192 ${t("feed_title")}<br><strong>{{filename}}</strong> \u2192 ${t("filename")}<br><strong>{{tags}}</strong> \u2192 ${t("article_tags")}<br><strong>{{media}}</strong> \u2192 ${t("article_media")}<br><strong>{{highlights}}</strong> \u2192 ${t("highlights")}`;
    new import_obsidian26.Setting(containerEl).setName(t("template_new")).setDesc(templateDesc).addTextArea((textArea) => {
      textArea.setValue(this.plugin.settings.template).setPlaceholder(DEFAULT_SETTINGS.template).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          template: value
        }));
      }));
      textArea.inputEl.setAttr("rows", 15);
      textArea.inputEl.setAttr("cols", 50);
    });
    const pasteTemplateDesc = new DocumentFragment();
    pasteTemplateDesc.createDiv().innerHTML = t("template_new_help") + "<br>" + t("available_variables") + `<br><strong>{{title}}</strong> \u2192 ${t("article_title")}<br><strong>{{link}}</strong> \u2192 ${t("article_link")}<br><strong>{{author}}</strong> \u2192 ${t("article_author")}<br><strong>{{published}}</strong> \u2192 ${t("article_published")}<br><strong>{{created}}</strong> \u2192 ${t("note_created")}<br><strong>{{description}}</strong> \u2192 ${t("article_description")}<br><strong>{{content}}</strong> \u2192 ${t("article_content")}<br><strong>{{folder}}</strong> \u2192 ${t("feed_folder")}<br><strong>{{feed}}</strong> \u2192 ${t("feed_title")}<br><strong>{{tags}}</strong> \u2192 ${t("article_tags")}<br><strong>{{media}}</strong> \u2192 ${t("article_media")}<br><strong>{{highlights}}</strong> \u2192 ${t("highlights")}`;
    new import_obsidian26.Setting(containerEl).setName(t("template_paste")).setDesc(pasteTemplateDesc).addTextArea((textArea) => {
      textArea.setValue(this.plugin.settings.pasteTemplate).setPlaceholder(DEFAULT_SETTINGS.pasteTemplate).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          pasteTemplate: value
        }));
      }));
      textArea.inputEl.setAttr("rows", 15);
      textArea.inputEl.setAttr("cols", 50);
    });
    new import_obsidian26.Setting(containerEl).setName(t("file_location")).setDesc(t("file_location_help")).addDropdown((dropdown) => __async(this, null, function* () {
      dropdown.addOption("default", t("file_location_default")).addOption("custom", t("file_location_custom")).setValue(this.plugin.settings.saveLocation).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({ saveLocation: value }));
        this.display();
      }));
    }));
    if (this.plugin.settings.saveLocation == "custom") {
      new import_obsidian26.Setting(containerEl).setName(t("file_location_folder")).setDesc(t("file_location_folder_help")).addSearch((search) => __async(this, null, function* () {
        new FolderSuggest(this.app, search.inputEl);
        search.setValue(this.plugin.settings.saveLocationFolder).setPlaceholder(DEFAULT_SETTINGS.saveLocationFolder).onChange((value) => __async(this, null, function* () {
          yield this.plugin.writeSettings(() => ({ saveLocationFolder: value }));
        }));
      }));
    }
    let dateFormatSampleEl;
    const dateFormat = new import_obsidian26.Setting(containerEl).setName(t("date_format")).addMomentFormat((format2) => {
      dateFormatSampleEl = format2.setDefaultFormat(DEFAULT_SETTINGS.dateFormat).setPlaceholder(DEFAULT_SETTINGS.dateFormat).setValue(this.plugin.settings.dateFormat).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({ dateFormat: value }));
      }));
    });
    const referenceLink = dateFormat.descEl.createEl("a");
    referenceLink.setAttr("href", "https://momentjs.com/docs/#/displaying/format/");
    referenceLink.setText(t("syntax_reference"));
    const text2 = dateFormat.descEl.createDiv("text");
    text2.setText(t("syntax_looks"));
    const sampleEl = text2.createSpan("sample");
    dateFormatSampleEl.setSampleEl(sampleEl);
    dateFormat.addExtraButton((button) => {
      button.setIcon("reset").setTooltip(t("reset")).onClick(() => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          dateFormat: DEFAULT_SETTINGS.dateFormat
        }));
        this.display();
      }));
    });
    new import_obsidian26.Setting(containerEl).setName(t("ask_filename")).setDesc(t("ask_filename_help")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.askForFilename).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          askForFilename: value
        }));
      }));
    });
    new import_obsidian26.Setting(containerEl).setName(t("default_filename")).setDesc(t("default_filename_help")).addText((text3) => {
      text3.setPlaceholder(DEFAULT_SETTINGS.defaultFilename).setValue(this.plugin.settings.defaultFilename).onChange((value) => __async(this, null, function* () {
        if (value.length > 0) {
          yield this.plugin.writeSettings(() => ({
            defaultFilename: value
          }));
        } else {
          new import_obsidian26.Notice(t("fix_errors"));
        }
      }));
    });
    containerEl.createEl("hr", { attr: { style: "border-top: 5px solid var(--background-modifier-border);" } });
    containerEl.createEl("h3", { text: "Misc" });
    const refresh = new import_obsidian26.Setting(containerEl).setName(t("refresh_time")).setDesc(t("refresh_time_help")).addText((text3) => {
      text3.setPlaceholder(String(DEFAULT_SETTINGS.updateTime)).setValue(String(this.plugin.settings.updateTime)).onChange((value) => __async(this, null, function* () {
        if (value.length === 0) {
          new import_obsidian26.Notice(t("specify_positive_number"));
          return;
        }
        if (Number(value) < 0) {
          new import_obsidian26.Notice(t("specify_positive_number"));
          return;
        }
        yield this.plugin.writeSettings(() => ({ updateTime: Number(value) }));
      }));
      text3.inputEl.setAttr("type", "number");
      text3.inputEl.setAttr("min", "1");
      text3.inputEl.setAttr("onkeypress", "return event.charCode >= 48 && event.charCode <= 57");
    });
    refresh.addExtraButton((button) => {
      button.setIcon("reset").setTooltip("restore default").onClick(() => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          updateTime: DEFAULT_SETTINGS.updateTime
        }));
        this.display();
      }));
    });
    new import_obsidian26.Setting(containerEl).setName(t("multi_device_usage")).setDesc(t("multi_device_usage_help")).addToggle((toggle) => {
      return toggle.setValue(this.plugin.settings.autoSync).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          autoSync: value
        }));
      }));
    });
    new import_obsidian26.Setting(containerEl).setName(t("display_style")).addDropdown((dropdown) => {
      return dropdown.addOption("list", t("list")).addOption("cards", t("cards")).setValue(this.plugin.settings.displayStyle).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          displayStyle: value
        }));
      }));
    });
    containerEl.createEl("h2", { text: t("content") });
    const filterContainer = containerEl.createDiv("filter-container");
    displayFilterSettings(this.plugin, filterContainer);
    const feedsContainer = containerEl.createDiv("feed-container");
    displayFeedSettings(this.plugin, feedsContainer);
    containerEl.createEl("hr", { attr: { style: "border-top: 5px solid var(--background-modifier-border);" } });
    const hotkeyContainer = containerEl.createDiv("hotkey-container");
    displayHotkeys(this.plugin, hotkeyContainer);
    containerEl.createEl("hr", { attr: { style: "border-top: 5px solid var(--background-modifier-border);" } });
    const details = containerEl.createEl("details");
    const summary = details.createEl("summary");
    summary.setText(t("advanced"));
    const advanced = details.createDiv("advanced");
    advanced.createEl("h3", { text: t("customize_terms") });
    advanced.createSpan({ text: "Change a few selected terms here. You can help translating the plugin " });
    advanced.createEl("a", { text: "here", href: "https://github.com/joethei/obsidian-rss/tree/master/src/l10n" });
    new import_obsidian26.Setting(advanced).setName(t("folders")).addText((text3) => {
      text3.setPlaceholder(t("folders")).setValue(this.plugin.settings.renamedText.folders).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          renamedText: __spreadProps(__spreadValues({}, this.plugin.settings.renamedText), {
            folders: value
          })
        }));
      }));
    });
    new import_obsidian26.Setting(advanced).setName(t("filtered_folders")).addText((text3) => {
      text3.setPlaceholder(t("filtered_folders")).setValue(this.plugin.settings.renamedText.filtered_folders).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          renamedText: __spreadProps(__spreadValues({}, this.plugin.settings.renamedText), {
            filtered_folders: value
          })
        }));
      }));
    });
    new import_obsidian26.Setting(advanced).setName(t("no_folder")).addText((text3) => {
      text3.setPlaceholder(t("no_folder")).setValue(this.plugin.settings.renamedText.no_folder).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          renamedText: __spreadProps(__spreadValues({}, this.plugin.settings.renamedText), {
            no_folder: value
          })
        }));
      }));
    });
    advanced.createEl("hr", { attr: { style: "border-top: 5px solid var(--background-modifier-border);" } });
    new import_obsidian26.Setting(advanced).setName(t("display_media")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.displayMedia).onChange((value) => __async(this, null, function* () {
        yield this.plugin.writeSettings(() => ({
          displayMedia: value
        }));
      }));
    });
  }
};

// src/modals/ArticleSuggestModal.ts
var import_obsidian27 = __toModule(require("obsidian"));
var ArticleSuggestModal = class extends import_obsidian27.SuggestModal {
  constructor(plugin, items) {
    super(plugin.app);
    this.plugin = plugin;
    this.items = items;
  }
  getItems() {
    return this.items;
  }
  onChooseSuggestion(item, _) {
    this.close();
    new ItemModal(this.plugin, item, this.items, false).open();
  }
  getSuggestions(query) {
    return this.items.filter((item) => {
      return item.title.toLowerCase().includes(query.toLowerCase()) || item.content.toLowerCase().includes(query.toLowerCase());
    });
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.title });
    el.createEl("small", { text: (0, import_obsidian27.moment)(item.pubDate).format(this.plugin.settings.dateFormat) + " " + item.creator });
  }
};

// src/main.ts
var RssReaderPlugin = class extends import_obsidian28.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log("loading plugin rss reader");
      this.register(settingsStore.subscribe((value) => {
        this.settings = value;
      }));
      yield this.loadSettings();
      this.addCommand({
        id: "rss-open",
        name: t("open"),
        checkCallback: (checking) => {
          if (checking) {
            return this.app.workspace.getLeavesOfType(VIEW_ID).length === 0;
          }
          this.initLeaf();
        }
      });
      this.addCommand({
        id: "rss-refresh",
        name: t("refresh_feeds"),
        callback: () => __async(this, null, function* () {
          yield this.updateFeeds();
        })
      });
      this.addCommand({
        id: "rss-cleanup",
        name: t("cleanup"),
        callback: () => __async(this, null, function* () {
          new CleanupModal(this).open();
        })
      });
      this.addCommand({
        id: "rss-open-feed",
        name: "Open Feed from URL",
        callback: () => __async(this, null, function* () {
          const input = new TextInputPrompt(this.app, "URL", "URL", "", "", t("open"));
          yield input.openAndGetValue((text2) => __async(this, null, function* () {
            const items = yield getFeedItems({ name: "", folder: "", url: text2.getValue() });
            if (!items || items.items.length === 0) {
              input.setValidationError(text2, t("invalid_feed"));
              return;
            }
            input.close();
            new ArticleSuggestModal(this, items.items).open();
          }));
        })
      });
      this.registerView(VIEW_ID, (leaf) => new ViewLoader(leaf, this));
      this.addSettingTab(new RSSReaderSettingsTab(this.app, this));
      let interval;
      if (this.settings.updateTime !== 0) {
        interval = window.setInterval(() => __async(this, null, function* () {
          yield this.updateFeeds();
        }), this.settings.updateTime * 60 * 1e3);
        this.registerInterval(interval);
      }
      if (this.settings.autoSync) {
        this.registerInterval(window.setInterval(() => __async(this, null, function* () {
          yield this.loadSettings();
        }), 1e3 * 60));
      }
      settingsStore.subscribe((settings) => {
        if (interval !== void 0)
          clearInterval(interval);
        if (settings.updateTime != 0) {
          interval = window.setInterval(() => __async(this, null, function* () {
            yield this.updateFeeds();
          }), settings.updateTime * 60 * 1e3);
          this.registerInterval(interval);
        }
        this.settings = settings;
        this.saveSettings();
      });
      this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
        yield this.migrateData();
        yield this.initLeaf();
        yield this.updateFeeds();
        feedsStore.subscribe((feeds) => {
          const sorted = (0, import_lodash6.default)(feeds, "folder");
          sortedFeedsStore.update(() => sorted);
          let items = [];
          for (const feed in Object.keys(feeds)) {
            const feedItems = feeds[feed].items;
            items = items.concat(feedItems);
          }
          const tags = [];
          for (const item of items) {
            if (item !== void 0)
              tags.push(...item.tags);
          }
          const fileTags = this.app.metadataCache.getTags();
          for (const tag of Object.keys(fileTags)) {
            tags.push(tag.replace("#", ""));
          }
          tagsStore.update(() => new Set(tags.filter((tag) => tag.length > 0)));
          const folders = [];
          for (const item of items) {
            if (item !== void 0)
              folders.push(item.folder);
          }
          folderStore.update(() => new Set(folders.filter((folder) => folder !== void 0 && folder.length > 0)));
          this.filterItems(items);
        });
      }));
    });
  }
  filterItems(items) {
    const filtered = new Array();
    for (const filter of this.settings.filtered) {
      const sortOrder = SortOrder[filter.sortOrder];
      let filteredItems;
      if (filter.read && filter.unread) {
        filteredItems = items.filter((item) => {
          return item.read === filter.read || item.read !== filter.unread;
        });
      } else if (filter.read) {
        filteredItems = items.filter((item) => {
          return item.read;
        });
      } else if (filter.unread) {
        filteredItems = items.filter((item) => {
          return !item.read;
        });
      }
      if (filter.favorites) {
        filteredItems = filteredItems.filter((item) => {
          return item.favorite === filter.favorites;
        });
      }
      if (filter.filterFolders.length > 0) {
        filteredItems = filteredItems.filter((item) => {
          return filter.filterFolders.includes(item.folder);
        });
      }
      if (filter.ignoreFolders.length > 0) {
        filteredItems = filteredItems.filter((item) => {
          return !filter.ignoreFolders.includes(item.folder);
        });
      }
      if (filter.filterFeeds.length > 0) {
        filteredItems = filteredItems.filter((item) => {
          return filter.filterFeeds.includes(item.feed);
        });
      }
      if (filter.ignoreFeeds.length > 0) {
        filteredItems = filteredItems.filter((item) => {
          return !filter.ignoreFeeds.includes(item.feed);
        });
      }
      if (filter.filterTags.length > 0) {
        filteredItems = filteredItems.filter((item) => {
          for (const tag of filter.filterTags) {
            if (!item.tags.contains(tag))
              return false;
          }
          return true;
        });
      }
      if (filter.ignoreTags.length > 0) {
        filteredItems = filteredItems.filter((item) => {
          for (const tag of filter.ignoreTags) {
            if (item.tags.contains(tag))
              return false;
          }
          return true;
        });
      }
      const sortedItems = this.sortItems(filteredItems, sortOrder);
      filtered.push({ filter, items: { items: sortedItems } });
    }
    filteredItemsStore.update(() => filtered);
  }
  sortItems(items, sortOrder) {
    if (!items)
      return items;
    if (sortOrder === SortOrder.ALPHABET_NORMAL) {
      return items.sort((a, b) => a.title.localeCompare(b.title));
    }
    if (sortOrder === SortOrder.ALPHABET_INVERTED) {
      return items.sort((a, b) => b.title.localeCompare(a.title));
    }
    if (sortOrder === SortOrder.DATE_NEWEST) {
      return items.sort((a, b) => window.moment(b.pubDate) - window.moment(a.pubDate));
    }
    if (sortOrder === SortOrder.DATE_OLDEST) {
      return items.sort((a, b) => window.moment(a.pubDate) - window.moment(b.pubDate));
    }
    return items;
  }
  updateFeeds() {
    return __async(this, null, function* () {
      console.log("updating feeds");
      function mergeArrayById(array1, array2) {
        const mergedObjectMap = (0, import_lodash8.default)(array1, "hash");
        const finalArray = [];
        for (const object of array2) {
          mergedObjectMap[object.hash] = __spreadValues(__spreadValues({}, mergedObjectMap[object.hash]), object);
        }
        (0, import_lodash9.default)(mergedObjectMap).forEach((object) => {
          finalArray.push(object);
        });
        return finalArray;
      }
      function customizer(objValue, srcValue) {
        if (Array.isArray(objValue)) {
          return mergeArrayById(objValue, srcValue);
        }
      }
      let result = [];
      for (const feed of this.settings.feeds) {
        const items2 = yield getFeedItems(feed);
        if (items2)
          result.push(items2);
      }
      const items = this.settings.items;
      for (const feed of items) {
        if (feed.hash === void 0 || feed.hash === "") {
          feed.hash = new import_ts_md53.Md5().appendStr(feed.name).appendStr(feed.folder ? feed.folder : "no-folder").end();
        }
        for (const item of feed.items) {
          if (item.folder !== feed.folder || item.feed !== feed.name) {
            feed.items.remove(item);
          }
          if (item.hash === void 0) {
            item.hash = new import_ts_md53.Md5().appendStr(item.title).appendStr(item.folder).appendStr(item.link).end();
          }
        }
      }
      result = (0, import_lodash7.default)(result, items, customizer);
      new import_obsidian28.Notice(t("refreshed_feeds"));
      yield this.writeFeedContent(() => result);
    });
  }
  onunload() {
    console.log("unloading plugin rss reader");
    this.app.workspace.getLeavesOfType(VIEW_ID).forEach((leaf) => leaf.detach());
  }
  initLeaf() {
    return __async(this, null, function* () {
      if (this.app.workspace.getLeavesOfType(VIEW_ID).length > 0) {
        return;
      }
      yield this.app.workspace.getRightLeaf(false).setViewState({
        type: VIEW_ID
      });
    });
  }
  migrateData() {
    return __async(this, null, function* () {
      const configPath = this.app.vault.configDir + "/plugins/rss-reader/data.json";
      const config = JSON.parse(yield this.app.vault.adapter.read(configPath));
      for (const feed of config.feeds) {
        if (feed.folder === void 0) {
          feed.folder = "";
        }
      }
      for (const feed of config.items) {
        if (feed.folder === void 0) {
          feed.folder = "";
        }
      }
      yield this.app.vault.adapter.write(configPath, JSON.stringify(config));
      if (config.filtered.length === 0)
        return;
      if (config.filtered[0].ignoreFolders === void 0) {
        new import_obsidian28.Notice("RSS Reader: migrating data");
        console.log("RSS Reader: adding ignored fields to filters");
        for (const filter of config.filtered) {
          filter.ignoreTags = [];
          filter.ignoreFolders = [];
          filter.ignoreFeeds = [];
        }
        yield this.app.vault.adapter.write(configPath, JSON.stringify(config));
        yield this.loadSettings();
        new import_obsidian28.Notice("RSS Reader: data has been migrated");
      }
      if (config.filtered[0].filterType === void 0)
        return;
      new import_obsidian28.Notice("RSS Reader: migrating data");
      for (const filter of config.filtered) {
        const newFilter = {
          filterFolders: [],
          filterTags: [],
          filterFeeds: [],
          favorites: false,
          read: false,
          unread: false,
          sortOrder: filter.sortOrder,
          name: filter.name,
          ignoreFolders: [],
          ignoreFeeds: [],
          ignoreTags: []
        };
        if (filter.filterType === "FAVORITES")
          newFilter.favorites = true;
        if (filter.filterType === "READ")
          newFilter.read = true;
        if (filter.filterType === "UNREAD")
          newFilter.unread = true;
        if (filter.filterType === "TAGS") {
          if (filter.filterContent !== "") {
            newFilter.filterTags = filter.filterContent.split(",");
          }
        } else {
          if (filter.filterContent !== "") {
            newFilter.filterFolders = filter.filterContent.split(",");
          }
        }
        newFilter.read = true;
        newFilter.unread = true;
        config.filtered = config.filtered.filter((item) => item.name !== filter.name);
        config.filtered.push(newFilter);
      }
      yield this.app.vault.adapter.write(configPath, JSON.stringify(config));
      yield this.loadSettings();
      new import_obsidian28.Notice("RSS Reader: data has been migrated");
      if (config.read === void 0)
        return;
      new import_obsidian28.Notice("RSS Reader: migrating data");
      for (const content of Object.values(config.items)) {
        for (const item of content.items) {
          if (config.read.items.some((readItem) => {
            return item.title == readItem.title && item.link == readItem.link && item.content == readItem.content;
          })) {
            item.read = true;
          }
        }
        for (const item of content.items) {
          if (config.favorites.items.some((favItem) => {
            return item.title == favItem.title && item.link == favItem.link && item.content == favItem.content;
          })) {
            item.favorite = true;
          }
        }
      }
      delete config.read;
      delete config.favorites;
      yield this.app.vault.adapter.write(configPath, JSON.stringify(config));
      yield this.loadSettings();
      new import_obsidian28.Notice("RSS Reader: data has been migrated");
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      const configPath = this.app.vault.configDir + "/plugins/rss-reader/data.json";
      let file;
      try {
        file = yield this.app.vault.adapter.read(configPath);
      } catch (e) {
        console.error(e);
      }
      if (file !== void 0) {
        try {
          JSON.parse(file);
        } catch (e) {
          console.log(t("RSS_Reader") + "  could not parse json, check if the plugins data.json is valid.");
          console.error(e);
          new import_obsidian28.Notice(t("RSS_Reader") + " could not parse plugin data. If this message keeps showing up, check the console");
          return Promise.resolve();
        }
      }
      const data = yield this.loadData();
      this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
      if (data !== void 0 && data !== null) {
        this.settings.hotkeys = Object.assign({}, DEFAULT_SETTINGS.hotkeys, data.hotkeys);
      }
      settingsStore.set(this.settings);
      configuredFeedsStore.set(this.settings.feeds);
      feedsStore.set(this.settings.items);
      foldedState.set(this.settings.folded);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  writeFeeds(changeOpts) {
    return __async(this, null, function* () {
      yield configuredFeedsStore.update((old) => __spreadValues(__spreadValues({}, old), changeOpts(old)));
      yield this.writeSettings((old) => ({
        feeds: changeOpts(old.feeds)
      }));
      yield this.updateFeeds();
    });
  }
  writeFeedContent(changeOpts) {
    return __async(this, null, function* () {
      yield feedsStore.update((old) => __spreadValues({}, changeOpts(old)));
      yield this.writeSettings((old) => ({
        items: changeOpts(old.items)
      }));
    });
  }
  writeFiltered(changeOpts) {
    return __async(this, null, function* () {
      yield filteredStore.update((old) => __spreadValues(__spreadValues({}, old), changeOpts(old)));
      yield this.writeSettings((old) => ({
        filtered: changeOpts(old.filtered)
      }));
      yield this.updateFeeds();
    });
  }
  writeFolded(folded) {
    return __async(this, null, function* () {
      yield foldedState.update(() => folded);
      yield this.writeSettings(() => ({
        folded
      }));
    });
  }
  writeSettings(changeOpts) {
    return __async(this, null, function* () {
      yield settingsStore.update((old) => __spreadValues(__spreadValues({}, old), changeOpts(old)));
    });
  }
};
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
